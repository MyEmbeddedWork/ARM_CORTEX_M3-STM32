.TH "C:/Users/anilj/Desktop/cmsis/sorc/system/include/cmsis/arm_math.h" 3 "Sun Apr 16 2017" "STM32_CMSIS" \" -*- nroff -*-
.ad l
.nh
.SH NAME
C:/Users/anilj/Desktop/cmsis/sorc/system/include/cmsis/arm_math.h
.SH SYNOPSIS
.br
.PP
\fC#include 'string\&.h'\fP
.br
\fC#include 'math\&.h'\fP
.br

.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBarm_fir_instance_q7\fP"
.br
.RI "Instance structure for the Q7 FIR filter\&. "
.ti -1c
.RI "struct \fBarm_fir_instance_q15\fP"
.br
.RI "Instance structure for the Q15 FIR filter\&. "
.ti -1c
.RI "struct \fBarm_fir_instance_q31\fP"
.br
.RI "Instance structure for the Q31 FIR filter\&. "
.ti -1c
.RI "struct \fBarm_fir_instance_f32\fP"
.br
.RI "Instance structure for the floating-point FIR filter\&. "
.ti -1c
.RI "struct \fBarm_biquad_casd_df1_inst_q15\fP"
.br
.RI "Instance structure for the Q15 Biquad cascade filter\&. "
.ti -1c
.RI "struct \fBarm_biquad_casd_df1_inst_q31\fP"
.br
.RI "Instance structure for the Q31 Biquad cascade filter\&. "
.ti -1c
.RI "struct \fBarm_biquad_casd_df1_inst_f32\fP"
.br
.RI "Instance structure for the floating-point Biquad cascade filter\&. "
.ti -1c
.RI "struct \fBarm_matrix_instance_f32\fP"
.br
.RI "Instance structure for the floating-point matrix structure\&. "
.ti -1c
.RI "struct \fBarm_matrix_instance_f64\fP"
.br
.RI "Instance structure for the floating-point matrix structure\&. "
.ti -1c
.RI "struct \fBarm_matrix_instance_q15\fP"
.br
.RI "Instance structure for the Q15 matrix structure\&. "
.ti -1c
.RI "struct \fBarm_matrix_instance_q31\fP"
.br
.RI "Instance structure for the Q31 matrix structure\&. "
.ti -1c
.RI "struct \fBarm_pid_instance_q15\fP"
.br
.RI "Instance structure for the Q15 PID Control\&. "
.ti -1c
.RI "struct \fBarm_pid_instance_q31\fP"
.br
.RI "Instance structure for the Q31 PID Control\&. "
.ti -1c
.RI "struct \fBarm_pid_instance_f32\fP"
.br
.RI "Instance structure for the floating-point PID Control\&. "
.ti -1c
.RI "struct \fBarm_linear_interp_instance_f32\fP"
.br
.RI "Instance structure for the floating-point Linear Interpolate function\&. "
.ti -1c
.RI "struct \fBarm_bilinear_interp_instance_f32\fP"
.br
.RI "Instance structure for the floating-point bilinear interpolation function\&. "
.ti -1c
.RI "struct \fBarm_bilinear_interp_instance_q31\fP"
.br
.RI "Instance structure for the Q31 bilinear interpolation function\&. "
.ti -1c
.RI "struct \fBarm_bilinear_interp_instance_q15\fP"
.br
.RI "Instance structure for the Q15 bilinear interpolation function\&. "
.ti -1c
.RI "struct \fBarm_bilinear_interp_instance_q7\fP"
.br
.RI "Instance structure for the Q15 bilinear interpolation function\&. "
.ti -1c
.RI "struct \fBarm_cfft_radix2_instance_q15\fP"
.br
.RI "Instance structure for the Q15 CFFT/CIFFT function\&. "
.ti -1c
.RI "struct \fBarm_cfft_radix4_instance_q15\fP"
.br
.RI "Instance structure for the Q15 CFFT/CIFFT function\&. "
.ti -1c
.RI "struct \fBarm_cfft_radix2_instance_q31\fP"
.br
.RI "Instance structure for the Radix-2 Q31 CFFT/CIFFT function\&. "
.ti -1c
.RI "struct \fBarm_cfft_radix4_instance_q31\fP"
.br
.RI "Instance structure for the Q31 CFFT/CIFFT function\&. "
.ti -1c
.RI "struct \fBarm_cfft_radix2_instance_f32\fP"
.br
.RI "Instance structure for the floating-point CFFT/CIFFT function\&. "
.ti -1c
.RI "struct \fBarm_cfft_radix4_instance_f32\fP"
.br
.RI "Instance structure for the floating-point CFFT/CIFFT function\&. "
.ti -1c
.RI "struct \fBarm_cfft_instance_q15\fP"
.br
.RI "Instance structure for the fixed-point CFFT/CIFFT function\&. "
.ti -1c
.RI "struct \fBarm_cfft_instance_q31\fP"
.br
.RI "Instance structure for the fixed-point CFFT/CIFFT function\&. "
.ti -1c
.RI "struct \fBarm_cfft_instance_f32\fP"
.br
.RI "Instance structure for the floating-point CFFT/CIFFT function\&. "
.ti -1c
.RI "struct \fBarm_rfft_instance_q15\fP"
.br
.RI "Instance structure for the Q15 RFFT/RIFFT function\&. "
.ti -1c
.RI "struct \fBarm_rfft_instance_q31\fP"
.br
.RI "Instance structure for the Q31 RFFT/RIFFT function\&. "
.ti -1c
.RI "struct \fBarm_rfft_instance_f32\fP"
.br
.RI "Instance structure for the floating-point RFFT/RIFFT function\&. "
.ti -1c
.RI "struct \fBarm_rfft_fast_instance_f32\fP"
.br
.RI "Instance structure for the floating-point RFFT/RIFFT function\&. "
.ti -1c
.RI "struct \fBarm_dct4_instance_f32\fP"
.br
.RI "Instance structure for the floating-point DCT4/IDCT4 function\&. "
.ti -1c
.RI "struct \fBarm_dct4_instance_q31\fP"
.br
.RI "Instance structure for the Q31 DCT4/IDCT4 function\&. "
.ti -1c
.RI "struct \fBarm_dct4_instance_q15\fP"
.br
.RI "Instance structure for the Q15 DCT4/IDCT4 function\&. "
.ti -1c
.RI "struct \fBarm_fir_decimate_instance_q15\fP"
.br
.RI "Instance structure for the Q15 FIR decimator\&. "
.ti -1c
.RI "struct \fBarm_fir_decimate_instance_q31\fP"
.br
.RI "Instance structure for the Q31 FIR decimator\&. "
.ti -1c
.RI "struct \fBarm_fir_decimate_instance_f32\fP"
.br
.RI "Instance structure for the floating-point FIR decimator\&. "
.ti -1c
.RI "struct \fBarm_fir_interpolate_instance_q15\fP"
.br
.RI "Instance structure for the Q15 FIR interpolator\&. "
.ti -1c
.RI "struct \fBarm_fir_interpolate_instance_q31\fP"
.br
.RI "Instance structure for the Q31 FIR interpolator\&. "
.ti -1c
.RI "struct \fBarm_fir_interpolate_instance_f32\fP"
.br
.RI "Instance structure for the floating-point FIR interpolator\&. "
.ti -1c
.RI "struct \fBarm_biquad_cas_df1_32x64_ins_q31\fP"
.br
.RI "Instance structure for the high precision Q31 Biquad cascade filter\&. "
.ti -1c
.RI "struct \fBarm_biquad_cascade_df2T_instance_f32\fP"
.br
.RI "Instance structure for the floating-point transposed direct form II Biquad cascade filter\&. "
.ti -1c
.RI "struct \fBarm_biquad_cascade_stereo_df2T_instance_f32\fP"
.br
.RI "Instance structure for the floating-point transposed direct form II Biquad cascade filter\&. "
.ti -1c
.RI "struct \fBarm_biquad_cascade_df2T_instance_f64\fP"
.br
.RI "Instance structure for the floating-point transposed direct form II Biquad cascade filter\&. "
.ti -1c
.RI "struct \fBarm_fir_lattice_instance_q15\fP"
.br
.RI "Instance structure for the Q15 FIR lattice filter\&. "
.ti -1c
.RI "struct \fBarm_fir_lattice_instance_q31\fP"
.br
.RI "Instance structure for the Q31 FIR lattice filter\&. "
.ti -1c
.RI "struct \fBarm_fir_lattice_instance_f32\fP"
.br
.RI "Instance structure for the floating-point FIR lattice filter\&. "
.ti -1c
.RI "struct \fBarm_iir_lattice_instance_q15\fP"
.br
.RI "Instance structure for the Q15 IIR lattice filter\&. "
.ti -1c
.RI "struct \fBarm_iir_lattice_instance_q31\fP"
.br
.RI "Instance structure for the Q31 IIR lattice filter\&. "
.ti -1c
.RI "struct \fBarm_iir_lattice_instance_f32\fP"
.br
.RI "Instance structure for the floating-point IIR lattice filter\&. "
.ti -1c
.RI "struct \fBarm_lms_instance_f32\fP"
.br
.RI "Instance structure for the floating-point LMS filter\&. "
.ti -1c
.RI "struct \fBarm_lms_instance_q15\fP"
.br
.RI "Instance structure for the Q15 LMS filter\&. "
.ti -1c
.RI "struct \fBarm_lms_instance_q31\fP"
.br
.RI "Instance structure for the Q31 LMS filter\&. "
.ti -1c
.RI "struct \fBarm_lms_norm_instance_f32\fP"
.br
.RI "Instance structure for the floating-point normalized LMS filter\&. "
.ti -1c
.RI "struct \fBarm_lms_norm_instance_q31\fP"
.br
.RI "Instance structure for the Q31 normalized LMS filter\&. "
.ti -1c
.RI "struct \fBarm_lms_norm_instance_q15\fP"
.br
.RI "Instance structure for the Q15 normalized LMS filter\&. "
.ti -1c
.RI "struct \fBarm_fir_sparse_instance_f32\fP"
.br
.RI "Instance structure for the floating-point sparse FIR filter\&. "
.ti -1c
.RI "struct \fBarm_fir_sparse_instance_q31\fP"
.br
.RI "Instance structure for the Q31 sparse FIR filter\&. "
.ti -1c
.RI "struct \fBarm_fir_sparse_instance_q15\fP"
.br
.RI "Instance structure for the Q15 sparse FIR filter\&. "
.ti -1c
.RI "struct \fBarm_fir_sparse_instance_q7\fP"
.br
.RI "Instance structure for the Q7 sparse FIR filter\&. "
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fB__CMSIS_GENERIC\fP   /* disable \fBNVIC\fP and Systick functions */"
.br
.ti -1c
.RI "#define \fBDELTA_Q31\fP   (0x100)"
.br
.RI "Macros required for reciprocal calculation in Normalized LMS\&. "
.ti -1c
.RI "#define \fBDELTA_Q15\fP   0x5"
.br
.ti -1c
.RI "#define \fBINDEX_MASK\fP   0x0000003F"
.br
.ti -1c
.RI "#define \fBPI\fP   3\&.14159265358979f"
.br
.ti -1c
.RI "#define \fBFAST_MATH_TABLE_SIZE\fP   512"
.br
.RI "Macros required for SINE and COSINE Fast math approximations\&. "
.ti -1c
.RI "#define \fBFAST_MATH_Q31_SHIFT\fP   (32 \- 10)"
.br
.ti -1c
.RI "#define \fBFAST_MATH_Q15_SHIFT\fP   (16 \- 10)"
.br
.ti -1c
.RI "#define \fBCONTROLLER_Q31_SHIFT\fP   (32 \- 9)"
.br
.ti -1c
.RI "#define \fBTABLE_SIZE\fP   256"
.br
.ti -1c
.RI "#define \fBTABLE_SPACING_Q31\fP   0x400000"
.br
.ti -1c
.RI "#define \fBTABLE_SPACING_Q15\fP   0x80"
.br
.ti -1c
.RI "#define \fBINPUT_SPACING\fP   0xB60B61"
.br
.RI "Macros required for SINE and COSINE Controller functions\&. "
.ti -1c
.RI "#define \fBALIGN4\fP"
.br
.RI "Macro for Unaligned Support\&. "
.ti -1c
.RI "#define \fB__SIMD32\fP(addr)   (*(__SIMD32_TYPE **) & (addr))"
.br
.RI "definition to read/write two 16 bit values\&. "
.ti -1c
.RI "#define \fB__SIMD32_CONST\fP(addr)   ((__SIMD32_TYPE *)(addr))"
.br
.ti -1c
.RI "#define \fB_SIMD32_OFFSET\fP(addr)   (*(__SIMD32_TYPE *)  (addr))"
.br
.ti -1c
.RI "#define \fB__SIMD64\fP(addr)   (*(int64_t **) & (addr))"
.br
.ti -1c
.RI "#define \fB__PACKq7\fP(v0,  v1,  v2,  v3)"
.br
.RI "definition to pack four 8 bit values\&. "
.ti -1c
.RI "#define \fBmultAcc_32x32_keep32_R\fP(a,  x,  y)   a = (\fBq31_t\fP) (((((\fBq63_t\fP) a) << 32) + ((\fBq63_t\fP) x * y) + 0x80000000LL ) >> 32)"
.br
.ti -1c
.RI "#define \fBmultSub_32x32_keep32_R\fP(a,  x,  y)   a = (\fBq31_t\fP) (((((\fBq63_t\fP) a) << 32) \- ((\fBq63_t\fP) x * y) + 0x80000000LL ) >> 32)"
.br
.ti -1c
.RI "#define \fBmult_32x32_keep32_R\fP(a,  x,  y)   a = (\fBq31_t\fP) (((\fBq63_t\fP) x * y + 0x80000000LL ) >> 32)"
.br
.ti -1c
.RI "#define \fBmultAcc_32x32_keep32\fP(a,  x,  y)   a += (\fBq31_t\fP) (((\fBq63_t\fP) x * y) >> 32)"
.br
.ti -1c
.RI "#define \fBmultSub_32x32_keep32\fP(a,  x,  y)   a \-= (\fBq31_t\fP) (((\fBq63_t\fP) x * y) >> 32)"
.br
.ti -1c
.RI "#define \fBmult_32x32_keep32\fP(a,  x,  y)   a = (\fBq31_t\fP) (((\fBq63_t\fP) x * y ) >> 32)"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef int8_t \fBq7_t\fP"
.br
.RI "8-bit fractional data type in 1\&.7 format\&. "
.ti -1c
.RI "typedef int16_t \fBq15_t\fP"
.br
.RI "16-bit fractional data type in 1\&.15 format\&. "
.ti -1c
.RI "typedef int32_t \fBq31_t\fP"
.br
.RI "32-bit fractional data type in 1\&.31 format\&. "
.ti -1c
.RI "typedef int64_t \fBq63_t\fP"
.br
.RI "64-bit fractional data type in 1\&.63 format\&. "
.ti -1c
.RI "typedef float \fBfloat32_t\fP"
.br
.RI "32-bit floating-point type definition\&. "
.ti -1c
.RI "typedef double \fBfloat64_t\fP"
.br
.RI "64-bit floating-point type definition\&. "
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBarm_status\fP { \fBARM_MATH_SUCCESS\fP = 0, \fBARM_MATH_ARGUMENT_ERROR\fP = -1, \fBARM_MATH_LENGTH_ERROR\fP = -2, \fBARM_MATH_SIZE_MISMATCH\fP = -3, \fBARM_MATH_NANINF\fP = -4, \fBARM_MATH_SINGULAR\fP = -5, \fBARM_MATH_TEST_FAILURE\fP = -6 }
.RI "Error status returned by some functions in the library\&. ""
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBarm_fir_q7\fP (const \fBarm_fir_instance_q7\fP *S, \fBq7_t\fP *pSrc, \fBq7_t\fP *pDst, uint32_t blockSize)"
.br
.RI "Processing function for the Q7 FIR filter\&. "
.ti -1c
.RI "void \fBarm_fir_init_q7\fP (\fBarm_fir_instance_q7\fP *S, uint16_t numTaps, \fBq7_t\fP *pCoeffs, \fBq7_t\fP *pState, uint32_t blockSize)"
.br
.RI "Initialization function for the Q7 FIR filter\&. "
.ti -1c
.RI "void \fBarm_fir_q15\fP (const \fBarm_fir_instance_q15\fP *S, \fBq15_t\fP *pSrc, \fBq15_t\fP *pDst, uint32_t blockSize)"
.br
.RI "Processing function for the Q15 FIR filter\&. "
.ti -1c
.RI "void \fBarm_fir_fast_q15\fP (const \fBarm_fir_instance_q15\fP *S, \fBq15_t\fP *pSrc, \fBq15_t\fP *pDst, uint32_t blockSize)"
.br
.RI "Processing function for the fast Q15 FIR filter for Cortex-M3 and Cortex-M4\&. "
.ti -1c
.RI "\fBarm_status\fP \fBarm_fir_init_q15\fP (\fBarm_fir_instance_q15\fP *S, uint16_t numTaps, \fBq15_t\fP *pCoeffs, \fBq15_t\fP *pState, uint32_t blockSize)"
.br
.RI "Initialization function for the Q15 FIR filter\&. "
.ti -1c
.RI "void \fBarm_fir_q31\fP (const \fBarm_fir_instance_q31\fP *S, \fBq31_t\fP *pSrc, \fBq31_t\fP *pDst, uint32_t blockSize)"
.br
.RI "Processing function for the Q31 FIR filter\&. "
.ti -1c
.RI "void \fBarm_fir_fast_q31\fP (const \fBarm_fir_instance_q31\fP *S, \fBq31_t\fP *pSrc, \fBq31_t\fP *pDst, uint32_t blockSize)"
.br
.RI "Processing function for the fast Q31 FIR filter for Cortex-M3 and Cortex-M4\&. "
.ti -1c
.RI "void \fBarm_fir_init_q31\fP (\fBarm_fir_instance_q31\fP *S, uint16_t numTaps, \fBq31_t\fP *pCoeffs, \fBq31_t\fP *pState, uint32_t blockSize)"
.br
.RI "Initialization function for the Q31 FIR filter\&. "
.ti -1c
.RI "void \fBarm_fir_f32\fP (const \fBarm_fir_instance_f32\fP *S, \fBfloat32_t\fP *pSrc, \fBfloat32_t\fP *pDst, uint32_t blockSize)"
.br
.RI "Processing function for the floating-point FIR filter\&. "
.ti -1c
.RI "void \fBarm_fir_init_f32\fP (\fBarm_fir_instance_f32\fP *S, uint16_t numTaps, \fBfloat32_t\fP *pCoeffs, \fBfloat32_t\fP *pState, uint32_t blockSize)"
.br
.RI "Initialization function for the floating-point FIR filter\&. "
.ti -1c
.RI "void \fBarm_biquad_cascade_df1_q15\fP (const \fBarm_biquad_casd_df1_inst_q15\fP *S, \fBq15_t\fP *pSrc, \fBq15_t\fP *pDst, uint32_t blockSize)"
.br
.RI "Processing function for the Q15 Biquad cascade filter\&. "
.ti -1c
.RI "void \fBarm_biquad_cascade_df1_init_q15\fP (\fBarm_biquad_casd_df1_inst_q15\fP *S, uint8_t numStages, \fBq15_t\fP *pCoeffs, \fBq15_t\fP *pState, int8_t postShift)"
.br
.RI "Initialization function for the Q15 Biquad cascade filter\&. "
.ti -1c
.RI "void \fBarm_biquad_cascade_df1_fast_q15\fP (const \fBarm_biquad_casd_df1_inst_q15\fP *S, \fBq15_t\fP *pSrc, \fBq15_t\fP *pDst, uint32_t blockSize)"
.br
.RI "Fast but less precise processing function for the Q15 Biquad cascade filter for Cortex-M3 and Cortex-M4\&. "
.ti -1c
.RI "void \fBarm_biquad_cascade_df1_q31\fP (const \fBarm_biquad_casd_df1_inst_q31\fP *S, \fBq31_t\fP *pSrc, \fBq31_t\fP *pDst, uint32_t blockSize)"
.br
.RI "Processing function for the Q31 Biquad cascade filter\&. "
.ti -1c
.RI "void \fBarm_biquad_cascade_df1_fast_q31\fP (const \fBarm_biquad_casd_df1_inst_q31\fP *S, \fBq31_t\fP *pSrc, \fBq31_t\fP *pDst, uint32_t blockSize)"
.br
.RI "Fast but less precise processing function for the Q31 Biquad cascade filter for Cortex-M3 and Cortex-M4\&. "
.ti -1c
.RI "void \fBarm_biquad_cascade_df1_init_q31\fP (\fBarm_biquad_casd_df1_inst_q31\fP *S, uint8_t numStages, \fBq31_t\fP *pCoeffs, \fBq31_t\fP *pState, int8_t postShift)"
.br
.RI "Initialization function for the Q31 Biquad cascade filter\&. "
.ti -1c
.RI "void \fBarm_biquad_cascade_df1_f32\fP (const \fBarm_biquad_casd_df1_inst_f32\fP *S, \fBfloat32_t\fP *pSrc, \fBfloat32_t\fP *pDst, uint32_t blockSize)"
.br
.RI "Processing function for the floating-point Biquad cascade filter\&. "
.ti -1c
.RI "void \fBarm_biquad_cascade_df1_init_f32\fP (\fBarm_biquad_casd_df1_inst_f32\fP *S, uint8_t numStages, \fBfloat32_t\fP *pCoeffs, \fBfloat32_t\fP *pState)"
.br
.RI "Initialization function for the floating-point Biquad cascade filter\&. "
.ti -1c
.RI "\fBarm_status\fP \fBarm_mat_add_f32\fP (const \fBarm_matrix_instance_f32\fP *pSrcA, const \fBarm_matrix_instance_f32\fP *pSrcB, \fBarm_matrix_instance_f32\fP *pDst)"
.br
.RI "Floating-point matrix addition\&. "
.ti -1c
.RI "\fBarm_status\fP \fBarm_mat_add_q15\fP (const \fBarm_matrix_instance_q15\fP *pSrcA, const \fBarm_matrix_instance_q15\fP *pSrcB, \fBarm_matrix_instance_q15\fP *pDst)"
.br
.RI "Q15 matrix addition\&. "
.ti -1c
.RI "\fBarm_status\fP \fBarm_mat_add_q31\fP (const \fBarm_matrix_instance_q31\fP *pSrcA, const \fBarm_matrix_instance_q31\fP *pSrcB, \fBarm_matrix_instance_q31\fP *pDst)"
.br
.RI "Q31 matrix addition\&. "
.ti -1c
.RI "\fBarm_status\fP \fBarm_mat_cmplx_mult_f32\fP (const \fBarm_matrix_instance_f32\fP *pSrcA, const \fBarm_matrix_instance_f32\fP *pSrcB, \fBarm_matrix_instance_f32\fP *pDst)"
.br
.RI "Floating-point, complex, matrix multiplication\&. "
.ti -1c
.RI "\fBarm_status\fP \fBarm_mat_cmplx_mult_q15\fP (const \fBarm_matrix_instance_q15\fP *pSrcA, const \fBarm_matrix_instance_q15\fP *pSrcB, \fBarm_matrix_instance_q15\fP *pDst, \fBq15_t\fP *pScratch)"
.br
.RI "Q15, complex, matrix multiplication\&. "
.ti -1c
.RI "\fBarm_status\fP \fBarm_mat_cmplx_mult_q31\fP (const \fBarm_matrix_instance_q31\fP *pSrcA, const \fBarm_matrix_instance_q31\fP *pSrcB, \fBarm_matrix_instance_q31\fP *pDst)"
.br
.RI "Q31, complex, matrix multiplication\&. "
.ti -1c
.RI "\fBarm_status\fP \fBarm_mat_trans_f32\fP (const \fBarm_matrix_instance_f32\fP *pSrc, \fBarm_matrix_instance_f32\fP *pDst)"
.br
.RI "Floating-point matrix transpose\&. "
.ti -1c
.RI "\fBarm_status\fP \fBarm_mat_trans_q15\fP (const \fBarm_matrix_instance_q15\fP *pSrc, \fBarm_matrix_instance_q15\fP *pDst)"
.br
.RI "Q15 matrix transpose\&. "
.ti -1c
.RI "\fBarm_status\fP \fBarm_mat_trans_q31\fP (const \fBarm_matrix_instance_q31\fP *pSrc, \fBarm_matrix_instance_q31\fP *pDst)"
.br
.RI "Q31 matrix transpose\&. "
.ti -1c
.RI "\fBarm_status\fP \fBarm_mat_mult_f32\fP (const \fBarm_matrix_instance_f32\fP *pSrcA, const \fBarm_matrix_instance_f32\fP *pSrcB, \fBarm_matrix_instance_f32\fP *pDst)"
.br
.RI "Floating-point matrix multiplication\&. "
.ti -1c
.RI "\fBarm_status\fP \fBarm_mat_mult_q15\fP (const \fBarm_matrix_instance_q15\fP *pSrcA, const \fBarm_matrix_instance_q15\fP *pSrcB, \fBarm_matrix_instance_q15\fP *pDst, \fBq15_t\fP *pState)"
.br
.RI "Q15 matrix multiplication\&. "
.ti -1c
.RI "\fBarm_status\fP \fBarm_mat_mult_fast_q15\fP (const \fBarm_matrix_instance_q15\fP *pSrcA, const \fBarm_matrix_instance_q15\fP *pSrcB, \fBarm_matrix_instance_q15\fP *pDst, \fBq15_t\fP *pState)"
.br
.RI "Q15 matrix multiplication (fast variant) for Cortex-M3 and Cortex-M4\&. "
.ti -1c
.RI "\fBarm_status\fP \fBarm_mat_mult_q31\fP (const \fBarm_matrix_instance_q31\fP *pSrcA, const \fBarm_matrix_instance_q31\fP *pSrcB, \fBarm_matrix_instance_q31\fP *pDst)"
.br
.RI "Q31 matrix multiplication\&. "
.ti -1c
.RI "\fBarm_status\fP \fBarm_mat_mult_fast_q31\fP (const \fBarm_matrix_instance_q31\fP *pSrcA, const \fBarm_matrix_instance_q31\fP *pSrcB, \fBarm_matrix_instance_q31\fP *pDst)"
.br
.RI "Q31 matrix multiplication (fast variant) for Cortex-M3 and Cortex-M4\&. "
.ti -1c
.RI "\fBarm_status\fP \fBarm_mat_sub_f32\fP (const \fBarm_matrix_instance_f32\fP *pSrcA, const \fBarm_matrix_instance_f32\fP *pSrcB, \fBarm_matrix_instance_f32\fP *pDst)"
.br
.RI "Floating-point matrix subtraction\&. "
.ti -1c
.RI "\fBarm_status\fP \fBarm_mat_sub_q15\fP (const \fBarm_matrix_instance_q15\fP *pSrcA, const \fBarm_matrix_instance_q15\fP *pSrcB, \fBarm_matrix_instance_q15\fP *pDst)"
.br
.RI "Q15 matrix subtraction\&. "
.ti -1c
.RI "\fBarm_status\fP \fBarm_mat_sub_q31\fP (const \fBarm_matrix_instance_q31\fP *pSrcA, const \fBarm_matrix_instance_q31\fP *pSrcB, \fBarm_matrix_instance_q31\fP *pDst)"
.br
.RI "Q31 matrix subtraction\&. "
.ti -1c
.RI "\fBarm_status\fP \fBarm_mat_scale_f32\fP (const \fBarm_matrix_instance_f32\fP *pSrc, \fBfloat32_t\fP scale, \fBarm_matrix_instance_f32\fP *pDst)"
.br
.RI "Floating-point matrix scaling\&. "
.ti -1c
.RI "\fBarm_status\fP \fBarm_mat_scale_q15\fP (const \fBarm_matrix_instance_q15\fP *pSrc, \fBq15_t\fP scaleFract, int32_t shift, \fBarm_matrix_instance_q15\fP *pDst)"
.br
.RI "Q15 matrix scaling\&. "
.ti -1c
.RI "\fBarm_status\fP \fBarm_mat_scale_q31\fP (const \fBarm_matrix_instance_q31\fP *pSrc, \fBq31_t\fP scaleFract, int32_t shift, \fBarm_matrix_instance_q31\fP *pDst)"
.br
.RI "Q31 matrix scaling\&. "
.ti -1c
.RI "void \fBarm_mat_init_q31\fP (\fBarm_matrix_instance_q31\fP *S, uint16_t nRows, uint16_t nColumns, \fBq31_t\fP *pData)"
.br
.RI "Q31 matrix initialization\&. "
.ti -1c
.RI "void \fBarm_mat_init_q15\fP (\fBarm_matrix_instance_q15\fP *S, uint16_t nRows, uint16_t nColumns, \fBq15_t\fP *pData)"
.br
.RI "Q15 matrix initialization\&. "
.ti -1c
.RI "void \fBarm_mat_init_f32\fP (\fBarm_matrix_instance_f32\fP *S, uint16_t nRows, uint16_t nColumns, \fBfloat32_t\fP *pData)"
.br
.RI "Floating-point matrix initialization\&. "
.ti -1c
.RI "void \fBarm_pid_init_f32\fP (\fBarm_pid_instance_f32\fP *S, int32_t resetStateFlag)"
.br
.RI "Initialization function for the floating-point PID Control\&. "
.ti -1c
.RI "void \fBarm_pid_reset_f32\fP (\fBarm_pid_instance_f32\fP *S)"
.br
.RI "Reset function for the floating-point PID Control\&. "
.ti -1c
.RI "void \fBarm_pid_init_q31\fP (\fBarm_pid_instance_q31\fP *S, int32_t resetStateFlag)"
.br
.RI "Initialization function for the Q31 PID Control\&. "
.ti -1c
.RI "void \fBarm_pid_reset_q31\fP (\fBarm_pid_instance_q31\fP *S)"
.br
.RI "Reset function for the Q31 PID Control\&. "
.ti -1c
.RI "void \fBarm_pid_init_q15\fP (\fBarm_pid_instance_q15\fP *S, int32_t resetStateFlag)"
.br
.RI "Initialization function for the Q15 PID Control\&. "
.ti -1c
.RI "void \fBarm_pid_reset_q15\fP (\fBarm_pid_instance_q15\fP *S)"
.br
.RI "Reset function for the Q15 PID Control\&. "
.ti -1c
.RI "void \fBarm_mult_q7\fP (\fBq7_t\fP *pSrcA, \fBq7_t\fP *pSrcB, \fBq7_t\fP *pDst, uint32_t blockSize)"
.br
.RI "Q7 vector multiplication\&. "
.ti -1c
.RI "void \fBarm_mult_q15\fP (\fBq15_t\fP *pSrcA, \fBq15_t\fP *pSrcB, \fBq15_t\fP *pDst, uint32_t blockSize)"
.br
.RI "Q15 vector multiplication\&. "
.ti -1c
.RI "void \fBarm_mult_q31\fP (\fBq31_t\fP *pSrcA, \fBq31_t\fP *pSrcB, \fBq31_t\fP *pDst, uint32_t blockSize)"
.br
.RI "Q31 vector multiplication\&. "
.ti -1c
.RI "void \fBarm_mult_f32\fP (\fBfloat32_t\fP *pSrcA, \fBfloat32_t\fP *pSrcB, \fBfloat32_t\fP *pDst, uint32_t blockSize)"
.br
.RI "Floating-point vector multiplication\&. "
.ti -1c
.RI "\fBarm_status\fP \fBarm_cfft_radix2_init_q15\fP (\fBarm_cfft_radix2_instance_q15\fP *S, uint16_t fftLen, uint8_t ifftFlag, uint8_t bitReverseFlag)"
.br
.ti -1c
.RI "void \fBarm_cfft_radix2_q15\fP (const \fBarm_cfft_radix2_instance_q15\fP *S, \fBq15_t\fP *pSrc)"
.br
.ti -1c
.RI "\fBarm_status\fP \fBarm_cfft_radix4_init_q15\fP (\fBarm_cfft_radix4_instance_q15\fP *S, uint16_t fftLen, uint8_t ifftFlag, uint8_t bitReverseFlag)"
.br
.ti -1c
.RI "void \fBarm_cfft_radix4_q15\fP (const \fBarm_cfft_radix4_instance_q15\fP *S, \fBq15_t\fP *pSrc)"
.br
.ti -1c
.RI "\fBarm_status\fP \fBarm_cfft_radix2_init_q31\fP (\fBarm_cfft_radix2_instance_q31\fP *S, uint16_t fftLen, uint8_t ifftFlag, uint8_t bitReverseFlag)"
.br
.ti -1c
.RI "void \fBarm_cfft_radix2_q31\fP (const \fBarm_cfft_radix2_instance_q31\fP *S, \fBq31_t\fP *pSrc)"
.br
.ti -1c
.RI "void \fBarm_cfft_radix4_q31\fP (const \fBarm_cfft_radix4_instance_q31\fP *S, \fBq31_t\fP *pSrc)"
.br
.ti -1c
.RI "\fBarm_status\fP \fBarm_cfft_radix4_init_q31\fP (\fBarm_cfft_radix4_instance_q31\fP *S, uint16_t fftLen, uint8_t ifftFlag, uint8_t bitReverseFlag)"
.br
.ti -1c
.RI "\fBarm_status\fP \fBarm_cfft_radix2_init_f32\fP (\fBarm_cfft_radix2_instance_f32\fP *S, uint16_t fftLen, uint8_t ifftFlag, uint8_t bitReverseFlag)"
.br
.ti -1c
.RI "void \fBarm_cfft_radix2_f32\fP (const \fBarm_cfft_radix2_instance_f32\fP *S, \fBfloat32_t\fP *pSrc)"
.br
.ti -1c
.RI "\fBarm_status\fP \fBarm_cfft_radix4_init_f32\fP (\fBarm_cfft_radix4_instance_f32\fP *S, uint16_t fftLen, uint8_t ifftFlag, uint8_t bitReverseFlag)"
.br
.ti -1c
.RI "void \fBarm_cfft_radix4_f32\fP (const \fBarm_cfft_radix4_instance_f32\fP *S, \fBfloat32_t\fP *pSrc)"
.br
.ti -1c
.RI "void \fBarm_cfft_q15\fP (const \fBarm_cfft_instance_q15\fP *S, \fBq15_t\fP *p1, uint8_t ifftFlag, uint8_t bitReverseFlag)"
.br
.ti -1c
.RI "void \fBarm_cfft_q31\fP (const \fBarm_cfft_instance_q31\fP *S, \fBq31_t\fP *p1, uint8_t ifftFlag, uint8_t bitReverseFlag)"
.br
.ti -1c
.RI "void \fBarm_cfft_f32\fP (const \fBarm_cfft_instance_f32\fP *S, \fBfloat32_t\fP *p1, uint8_t ifftFlag, uint8_t bitReverseFlag)"
.br
.ti -1c
.RI "\fBarm_status\fP \fBarm_rfft_init_q15\fP (\fBarm_rfft_instance_q15\fP *S, uint32_t fftLenReal, uint32_t ifftFlagR, uint32_t bitReverseFlag)"
.br
.ti -1c
.RI "void \fBarm_rfft_q15\fP (const \fBarm_rfft_instance_q15\fP *S, \fBq15_t\fP *pSrc, \fBq15_t\fP *pDst)"
.br
.ti -1c
.RI "\fBarm_status\fP \fBarm_rfft_init_q31\fP (\fBarm_rfft_instance_q31\fP *S, uint32_t fftLenReal, uint32_t ifftFlagR, uint32_t bitReverseFlag)"
.br
.ti -1c
.RI "void \fBarm_rfft_q31\fP (const \fBarm_rfft_instance_q31\fP *S, \fBq31_t\fP *pSrc, \fBq31_t\fP *pDst)"
.br
.ti -1c
.RI "\fBarm_status\fP \fBarm_rfft_init_f32\fP (\fBarm_rfft_instance_f32\fP *S, \fBarm_cfft_radix4_instance_f32\fP *S_CFFT, uint32_t fftLenReal, uint32_t ifftFlagR, uint32_t bitReverseFlag)"
.br
.ti -1c
.RI "void \fBarm_rfft_f32\fP (const \fBarm_rfft_instance_f32\fP *S, \fBfloat32_t\fP *pSrc, \fBfloat32_t\fP *pDst)"
.br
.ti -1c
.RI "\fBarm_status\fP \fBarm_rfft_fast_init_f32\fP (\fBarm_rfft_fast_instance_f32\fP *S, uint16_t fftLen)"
.br
.ti -1c
.RI "void \fBarm_rfft_fast_f32\fP (\fBarm_rfft_fast_instance_f32\fP *S, \fBfloat32_t\fP *p, \fBfloat32_t\fP *pOut, uint8_t ifftFlag)"
.br
.ti -1c
.RI "\fBarm_status\fP \fBarm_dct4_init_f32\fP (\fBarm_dct4_instance_f32\fP *S, \fBarm_rfft_instance_f32\fP *S_RFFT, \fBarm_cfft_radix4_instance_f32\fP *S_CFFT, uint16_t N, uint16_t Nby2, \fBfloat32_t\fP normalize)"
.br
.RI "Initialization function for the floating-point DCT4/IDCT4\&. "
.ti -1c
.RI "void \fBarm_dct4_f32\fP (const \fBarm_dct4_instance_f32\fP *S, \fBfloat32_t\fP *pState, \fBfloat32_t\fP *pInlineBuffer)"
.br
.RI "Processing function for the floating-point DCT4/IDCT4\&. "
.ti -1c
.RI "\fBarm_status\fP \fBarm_dct4_init_q31\fP (\fBarm_dct4_instance_q31\fP *S, \fBarm_rfft_instance_q31\fP *S_RFFT, \fBarm_cfft_radix4_instance_q31\fP *S_CFFT, uint16_t N, uint16_t Nby2, \fBq31_t\fP normalize)"
.br
.RI "Initialization function for the Q31 DCT4/IDCT4\&. "
.ti -1c
.RI "void \fBarm_dct4_q31\fP (const \fBarm_dct4_instance_q31\fP *S, \fBq31_t\fP *pState, \fBq31_t\fP *pInlineBuffer)"
.br
.RI "Processing function for the Q31 DCT4/IDCT4\&. "
.ti -1c
.RI "\fBarm_status\fP \fBarm_dct4_init_q15\fP (\fBarm_dct4_instance_q15\fP *S, \fBarm_rfft_instance_q15\fP *S_RFFT, \fBarm_cfft_radix4_instance_q15\fP *S_CFFT, uint16_t N, uint16_t Nby2, \fBq15_t\fP normalize)"
.br
.RI "Initialization function for the Q15 DCT4/IDCT4\&. "
.ti -1c
.RI "void \fBarm_dct4_q15\fP (const \fBarm_dct4_instance_q15\fP *S, \fBq15_t\fP *pState, \fBq15_t\fP *pInlineBuffer)"
.br
.RI "Processing function for the Q15 DCT4/IDCT4\&. "
.ti -1c
.RI "void \fBarm_add_f32\fP (\fBfloat32_t\fP *pSrcA, \fBfloat32_t\fP *pSrcB, \fBfloat32_t\fP *pDst, uint32_t blockSize)"
.br
.RI "Floating-point vector addition\&. "
.ti -1c
.RI "void \fBarm_add_q7\fP (\fBq7_t\fP *pSrcA, \fBq7_t\fP *pSrcB, \fBq7_t\fP *pDst, uint32_t blockSize)"
.br
.RI "Q7 vector addition\&. "
.ti -1c
.RI "void \fBarm_add_q15\fP (\fBq15_t\fP *pSrcA, \fBq15_t\fP *pSrcB, \fBq15_t\fP *pDst, uint32_t blockSize)"
.br
.RI "Q15 vector addition\&. "
.ti -1c
.RI "void \fBarm_add_q31\fP (\fBq31_t\fP *pSrcA, \fBq31_t\fP *pSrcB, \fBq31_t\fP *pDst, uint32_t blockSize)"
.br
.RI "Q31 vector addition\&. "
.ti -1c
.RI "void \fBarm_sub_f32\fP (\fBfloat32_t\fP *pSrcA, \fBfloat32_t\fP *pSrcB, \fBfloat32_t\fP *pDst, uint32_t blockSize)"
.br
.RI "Floating-point vector subtraction\&. "
.ti -1c
.RI "void \fBarm_sub_q7\fP (\fBq7_t\fP *pSrcA, \fBq7_t\fP *pSrcB, \fBq7_t\fP *pDst, uint32_t blockSize)"
.br
.RI "Q7 vector subtraction\&. "
.ti -1c
.RI "void \fBarm_sub_q15\fP (\fBq15_t\fP *pSrcA, \fBq15_t\fP *pSrcB, \fBq15_t\fP *pDst, uint32_t blockSize)"
.br
.RI "Q15 vector subtraction\&. "
.ti -1c
.RI "void \fBarm_sub_q31\fP (\fBq31_t\fP *pSrcA, \fBq31_t\fP *pSrcB, \fBq31_t\fP *pDst, uint32_t blockSize)"
.br
.RI "Q31 vector subtraction\&. "
.ti -1c
.RI "void \fBarm_scale_f32\fP (\fBfloat32_t\fP *pSrc, \fBfloat32_t\fP scale, \fBfloat32_t\fP *pDst, uint32_t blockSize)"
.br
.RI "Multiplies a floating-point vector by a scalar\&. "
.ti -1c
.RI "void \fBarm_scale_q7\fP (\fBq7_t\fP *pSrc, \fBq7_t\fP scaleFract, int8_t shift, \fBq7_t\fP *pDst, uint32_t blockSize)"
.br
.RI "Multiplies a Q7 vector by a scalar\&. "
.ti -1c
.RI "void \fBarm_scale_q15\fP (\fBq15_t\fP *pSrc, \fBq15_t\fP scaleFract, int8_t shift, \fBq15_t\fP *pDst, uint32_t blockSize)"
.br
.RI "Multiplies a Q15 vector by a scalar\&. "
.ti -1c
.RI "void \fBarm_scale_q31\fP (\fBq31_t\fP *pSrc, \fBq31_t\fP scaleFract, int8_t shift, \fBq31_t\fP *pDst, uint32_t blockSize)"
.br
.RI "Multiplies a Q31 vector by a scalar\&. "
.ti -1c
.RI "void \fBarm_abs_q7\fP (\fBq7_t\fP *pSrc, \fBq7_t\fP *pDst, uint32_t blockSize)"
.br
.RI "Q7 vector absolute value\&. "
.ti -1c
.RI "void \fBarm_abs_f32\fP (\fBfloat32_t\fP *pSrc, \fBfloat32_t\fP *pDst, uint32_t blockSize)"
.br
.RI "Floating-point vector absolute value\&. "
.ti -1c
.RI "void \fBarm_abs_q15\fP (\fBq15_t\fP *pSrc, \fBq15_t\fP *pDst, uint32_t blockSize)"
.br
.RI "Q15 vector absolute value\&. "
.ti -1c
.RI "void \fBarm_abs_q31\fP (\fBq31_t\fP *pSrc, \fBq31_t\fP *pDst, uint32_t blockSize)"
.br
.RI "Q31 vector absolute value\&. "
.ti -1c
.RI "void \fBarm_dot_prod_f32\fP (\fBfloat32_t\fP *pSrcA, \fBfloat32_t\fP *pSrcB, uint32_t blockSize, \fBfloat32_t\fP *result)"
.br
.RI "Dot product of floating-point vectors\&. "
.ti -1c
.RI "void \fBarm_dot_prod_q7\fP (\fBq7_t\fP *pSrcA, \fBq7_t\fP *pSrcB, uint32_t blockSize, \fBq31_t\fP *result)"
.br
.RI "Dot product of Q7 vectors\&. "
.ti -1c
.RI "void \fBarm_dot_prod_q15\fP (\fBq15_t\fP *pSrcA, \fBq15_t\fP *pSrcB, uint32_t blockSize, \fBq63_t\fP *result)"
.br
.RI "Dot product of Q15 vectors\&. "
.ti -1c
.RI "void \fBarm_dot_prod_q31\fP (\fBq31_t\fP *pSrcA, \fBq31_t\fP *pSrcB, uint32_t blockSize, \fBq63_t\fP *result)"
.br
.RI "Dot product of Q31 vectors\&. "
.ti -1c
.RI "void \fBarm_shift_q7\fP (\fBq7_t\fP *pSrc, int8_t shiftBits, \fBq7_t\fP *pDst, uint32_t blockSize)"
.br
.RI "Shifts the elements of a Q7 vector a specified number of bits\&. "
.ti -1c
.RI "void \fBarm_shift_q15\fP (\fBq15_t\fP *pSrc, int8_t shiftBits, \fBq15_t\fP *pDst, uint32_t blockSize)"
.br
.RI "Shifts the elements of a Q15 vector a specified number of bits\&. "
.ti -1c
.RI "void \fBarm_shift_q31\fP (\fBq31_t\fP *pSrc, int8_t shiftBits, \fBq31_t\fP *pDst, uint32_t blockSize)"
.br
.RI "Shifts the elements of a Q31 vector a specified number of bits\&. "
.ti -1c
.RI "void \fBarm_offset_f32\fP (\fBfloat32_t\fP *pSrc, \fBfloat32_t\fP offset, \fBfloat32_t\fP *pDst, uint32_t blockSize)"
.br
.RI "Adds a constant offset to a floating-point vector\&. "
.ti -1c
.RI "void \fBarm_offset_q7\fP (\fBq7_t\fP *pSrc, \fBq7_t\fP offset, \fBq7_t\fP *pDst, uint32_t blockSize)"
.br
.RI "Adds a constant offset to a Q7 vector\&. "
.ti -1c
.RI "void \fBarm_offset_q15\fP (\fBq15_t\fP *pSrc, \fBq15_t\fP offset, \fBq15_t\fP *pDst, uint32_t blockSize)"
.br
.RI "Adds a constant offset to a Q15 vector\&. "
.ti -1c
.RI "void \fBarm_offset_q31\fP (\fBq31_t\fP *pSrc, \fBq31_t\fP offset, \fBq31_t\fP *pDst, uint32_t blockSize)"
.br
.RI "Adds a constant offset to a Q31 vector\&. "
.ti -1c
.RI "void \fBarm_negate_f32\fP (\fBfloat32_t\fP *pSrc, \fBfloat32_t\fP *pDst, uint32_t blockSize)"
.br
.RI "Negates the elements of a floating-point vector\&. "
.ti -1c
.RI "void \fBarm_negate_q7\fP (\fBq7_t\fP *pSrc, \fBq7_t\fP *pDst, uint32_t blockSize)"
.br
.RI "Negates the elements of a Q7 vector\&. "
.ti -1c
.RI "void \fBarm_negate_q15\fP (\fBq15_t\fP *pSrc, \fBq15_t\fP *pDst, uint32_t blockSize)"
.br
.RI "Negates the elements of a Q15 vector\&. "
.ti -1c
.RI "void \fBarm_negate_q31\fP (\fBq31_t\fP *pSrc, \fBq31_t\fP *pDst, uint32_t blockSize)"
.br
.RI "Negates the elements of a Q31 vector\&. "
.ti -1c
.RI "void \fBarm_copy_f32\fP (\fBfloat32_t\fP *pSrc, \fBfloat32_t\fP *pDst, uint32_t blockSize)"
.br
.RI "Copies the elements of a floating-point vector\&. "
.ti -1c
.RI "void \fBarm_copy_q7\fP (\fBq7_t\fP *pSrc, \fBq7_t\fP *pDst, uint32_t blockSize)"
.br
.RI "Copies the elements of a Q7 vector\&. "
.ti -1c
.RI "void \fBarm_copy_q15\fP (\fBq15_t\fP *pSrc, \fBq15_t\fP *pDst, uint32_t blockSize)"
.br
.RI "Copies the elements of a Q15 vector\&. "
.ti -1c
.RI "void \fBarm_copy_q31\fP (\fBq31_t\fP *pSrc, \fBq31_t\fP *pDst, uint32_t blockSize)"
.br
.RI "Copies the elements of a Q31 vector\&. "
.ti -1c
.RI "void \fBarm_fill_f32\fP (\fBfloat32_t\fP \fBvalue\fP, \fBfloat32_t\fP *pDst, uint32_t blockSize)"
.br
.RI "Fills a constant value into a floating-point vector\&. "
.ti -1c
.RI "void \fBarm_fill_q7\fP (\fBq7_t\fP \fBvalue\fP, \fBq7_t\fP *pDst, uint32_t blockSize)"
.br
.RI "Fills a constant value into a Q7 vector\&. "
.ti -1c
.RI "void \fBarm_fill_q15\fP (\fBq15_t\fP \fBvalue\fP, \fBq15_t\fP *pDst, uint32_t blockSize)"
.br
.RI "Fills a constant value into a Q15 vector\&. "
.ti -1c
.RI "void \fBarm_fill_q31\fP (\fBq31_t\fP \fBvalue\fP, \fBq31_t\fP *pDst, uint32_t blockSize)"
.br
.RI "Fills a constant value into a Q31 vector\&. "
.ti -1c
.RI "void \fBarm_conv_f32\fP (\fBfloat32_t\fP *pSrcA, uint32_t srcALen, \fBfloat32_t\fP *pSrcB, uint32_t srcBLen, \fBfloat32_t\fP *pDst)"
.br
.RI "Convolution of floating-point sequences\&. "
.ti -1c
.RI "void \fBarm_conv_opt_q15\fP (\fBq15_t\fP *pSrcA, uint32_t srcALen, \fBq15_t\fP *pSrcB, uint32_t srcBLen, \fBq15_t\fP *pDst, \fBq15_t\fP *pScratch1, \fBq15_t\fP *pScratch2)"
.br
.RI "Convolution of Q15 sequences\&. "
.ti -1c
.RI "void \fBarm_conv_q15\fP (\fBq15_t\fP *pSrcA, uint32_t srcALen, \fBq15_t\fP *pSrcB, uint32_t srcBLen, \fBq15_t\fP *pDst)"
.br
.RI "Convolution of Q15 sequences\&. "
.ti -1c
.RI "void \fBarm_conv_fast_q15\fP (\fBq15_t\fP *pSrcA, uint32_t srcALen, \fBq15_t\fP *pSrcB, uint32_t srcBLen, \fBq15_t\fP *pDst)"
.br
.RI "Convolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4\&. "
.ti -1c
.RI "void \fBarm_conv_fast_opt_q15\fP (\fBq15_t\fP *pSrcA, uint32_t srcALen, \fBq15_t\fP *pSrcB, uint32_t srcBLen, \fBq15_t\fP *pDst, \fBq15_t\fP *pScratch1, \fBq15_t\fP *pScratch2)"
.br
.RI "Convolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4\&. "
.ti -1c
.RI "void \fBarm_conv_q31\fP (\fBq31_t\fP *pSrcA, uint32_t srcALen, \fBq31_t\fP *pSrcB, uint32_t srcBLen, \fBq31_t\fP *pDst)"
.br
.RI "Convolution of Q31 sequences\&. "
.ti -1c
.RI "void \fBarm_conv_fast_q31\fP (\fBq31_t\fP *pSrcA, uint32_t srcALen, \fBq31_t\fP *pSrcB, uint32_t srcBLen, \fBq31_t\fP *pDst)"
.br
.RI "Convolution of Q31 sequences (fast version) for Cortex-M3 and Cortex-M4\&. "
.ti -1c
.RI "void \fBarm_conv_opt_q7\fP (\fBq7_t\fP *pSrcA, uint32_t srcALen, \fBq7_t\fP *pSrcB, uint32_t srcBLen, \fBq7_t\fP *pDst, \fBq15_t\fP *pScratch1, \fBq15_t\fP *pScratch2)"
.br
.RI "Convolution of Q7 sequences\&. "
.ti -1c
.RI "void \fBarm_conv_q7\fP (\fBq7_t\fP *pSrcA, uint32_t srcALen, \fBq7_t\fP *pSrcB, uint32_t srcBLen, \fBq7_t\fP *pDst)"
.br
.RI "Convolution of Q7 sequences\&. "
.ti -1c
.RI "\fBarm_status\fP \fBarm_conv_partial_f32\fP (\fBfloat32_t\fP *pSrcA, uint32_t srcALen, \fBfloat32_t\fP *pSrcB, uint32_t srcBLen, \fBfloat32_t\fP *pDst, uint32_t firstIndex, uint32_t numPoints)"
.br
.RI "Partial convolution of floating-point sequences\&. "
.ti -1c
.RI "\fBarm_status\fP \fBarm_conv_partial_opt_q15\fP (\fBq15_t\fP *pSrcA, uint32_t srcALen, \fBq15_t\fP *pSrcB, uint32_t srcBLen, \fBq15_t\fP *pDst, uint32_t firstIndex, uint32_t numPoints, \fBq15_t\fP *pScratch1, \fBq15_t\fP *pScratch2)"
.br
.RI "Partial convolution of Q15 sequences\&. "
.ti -1c
.RI "\fBarm_status\fP \fBarm_conv_partial_q15\fP (\fBq15_t\fP *pSrcA, uint32_t srcALen, \fBq15_t\fP *pSrcB, uint32_t srcBLen, \fBq15_t\fP *pDst, uint32_t firstIndex, uint32_t numPoints)"
.br
.RI "Partial convolution of Q15 sequences\&. "
.ti -1c
.RI "\fBarm_status\fP \fBarm_conv_partial_fast_q15\fP (\fBq15_t\fP *pSrcA, uint32_t srcALen, \fBq15_t\fP *pSrcB, uint32_t srcBLen, \fBq15_t\fP *pDst, uint32_t firstIndex, uint32_t numPoints)"
.br
.RI "Partial convolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4\&. "
.ti -1c
.RI "\fBarm_status\fP \fBarm_conv_partial_fast_opt_q15\fP (\fBq15_t\fP *pSrcA, uint32_t srcALen, \fBq15_t\fP *pSrcB, uint32_t srcBLen, \fBq15_t\fP *pDst, uint32_t firstIndex, uint32_t numPoints, \fBq15_t\fP *pScratch1, \fBq15_t\fP *pScratch2)"
.br
.RI "Partial convolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4\&. "
.ti -1c
.RI "\fBarm_status\fP \fBarm_conv_partial_q31\fP (\fBq31_t\fP *pSrcA, uint32_t srcALen, \fBq31_t\fP *pSrcB, uint32_t srcBLen, \fBq31_t\fP *pDst, uint32_t firstIndex, uint32_t numPoints)"
.br
.RI "Partial convolution of Q31 sequences\&. "
.ti -1c
.RI "\fBarm_status\fP \fBarm_conv_partial_fast_q31\fP (\fBq31_t\fP *pSrcA, uint32_t srcALen, \fBq31_t\fP *pSrcB, uint32_t srcBLen, \fBq31_t\fP *pDst, uint32_t firstIndex, uint32_t numPoints)"
.br
.RI "Partial convolution of Q31 sequences (fast version) for Cortex-M3 and Cortex-M4\&. "
.ti -1c
.RI "\fBarm_status\fP \fBarm_conv_partial_opt_q7\fP (\fBq7_t\fP *pSrcA, uint32_t srcALen, \fBq7_t\fP *pSrcB, uint32_t srcBLen, \fBq7_t\fP *pDst, uint32_t firstIndex, uint32_t numPoints, \fBq15_t\fP *pScratch1, \fBq15_t\fP *pScratch2)"
.br
.RI "Partial convolution of Q7 sequences\&. "
.ti -1c
.RI "\fBarm_status\fP \fBarm_conv_partial_q7\fP (\fBq7_t\fP *pSrcA, uint32_t srcALen, \fBq7_t\fP *pSrcB, uint32_t srcBLen, \fBq7_t\fP *pDst, uint32_t firstIndex, uint32_t numPoints)"
.br
.RI "Partial convolution of Q7 sequences\&. "
.ti -1c
.RI "void \fBarm_fir_decimate_f32\fP (const \fBarm_fir_decimate_instance_f32\fP *S, \fBfloat32_t\fP *pSrc, \fBfloat32_t\fP *pDst, uint32_t blockSize)"
.br
.RI "Processing function for the floating-point FIR decimator\&. "
.ti -1c
.RI "\fBarm_status\fP \fBarm_fir_decimate_init_f32\fP (\fBarm_fir_decimate_instance_f32\fP *S, uint16_t numTaps, uint8_t M, \fBfloat32_t\fP *pCoeffs, \fBfloat32_t\fP *pState, uint32_t blockSize)"
.br
.RI "Initialization function for the floating-point FIR decimator\&. "
.ti -1c
.RI "void \fBarm_fir_decimate_q15\fP (const \fBarm_fir_decimate_instance_q15\fP *S, \fBq15_t\fP *pSrc, \fBq15_t\fP *pDst, uint32_t blockSize)"
.br
.RI "Processing function for the Q15 FIR decimator\&. "
.ti -1c
.RI "void \fBarm_fir_decimate_fast_q15\fP (const \fBarm_fir_decimate_instance_q15\fP *S, \fBq15_t\fP *pSrc, \fBq15_t\fP *pDst, uint32_t blockSize)"
.br
.RI "Processing function for the Q15 FIR decimator (fast variant) for Cortex-M3 and Cortex-M4\&. "
.ti -1c
.RI "\fBarm_status\fP \fBarm_fir_decimate_init_q15\fP (\fBarm_fir_decimate_instance_q15\fP *S, uint16_t numTaps, uint8_t M, \fBq15_t\fP *pCoeffs, \fBq15_t\fP *pState, uint32_t blockSize)"
.br
.RI "Initialization function for the Q15 FIR decimator\&. "
.ti -1c
.RI "void \fBarm_fir_decimate_q31\fP (const \fBarm_fir_decimate_instance_q31\fP *S, \fBq31_t\fP *pSrc, \fBq31_t\fP *pDst, uint32_t blockSize)"
.br
.RI "Processing function for the Q31 FIR decimator\&. "
.ti -1c
.RI "void \fBarm_fir_decimate_fast_q31\fP (\fBarm_fir_decimate_instance_q31\fP *S, \fBq31_t\fP *pSrc, \fBq31_t\fP *pDst, uint32_t blockSize)"
.br
.RI "Processing function for the Q31 FIR decimator (fast variant) for Cortex-M3 and Cortex-M4\&. "
.ti -1c
.RI "\fBarm_status\fP \fBarm_fir_decimate_init_q31\fP (\fBarm_fir_decimate_instance_q31\fP *S, uint16_t numTaps, uint8_t M, \fBq31_t\fP *pCoeffs, \fBq31_t\fP *pState, uint32_t blockSize)"
.br
.RI "Initialization function for the Q31 FIR decimator\&. "
.ti -1c
.RI "void \fBarm_fir_interpolate_q15\fP (const \fBarm_fir_interpolate_instance_q15\fP *S, \fBq15_t\fP *pSrc, \fBq15_t\fP *pDst, uint32_t blockSize)"
.br
.RI "Processing function for the Q15 FIR interpolator\&. "
.ti -1c
.RI "\fBarm_status\fP \fBarm_fir_interpolate_init_q15\fP (\fBarm_fir_interpolate_instance_q15\fP *S, uint8_t L, uint16_t numTaps, \fBq15_t\fP *pCoeffs, \fBq15_t\fP *pState, uint32_t blockSize)"
.br
.RI "Initialization function for the Q15 FIR interpolator\&. "
.ti -1c
.RI "void \fBarm_fir_interpolate_q31\fP (const \fBarm_fir_interpolate_instance_q31\fP *S, \fBq31_t\fP *pSrc, \fBq31_t\fP *pDst, uint32_t blockSize)"
.br
.RI "Processing function for the Q31 FIR interpolator\&. "
.ti -1c
.RI "\fBarm_status\fP \fBarm_fir_interpolate_init_q31\fP (\fBarm_fir_interpolate_instance_q31\fP *S, uint8_t L, uint16_t numTaps, \fBq31_t\fP *pCoeffs, \fBq31_t\fP *pState, uint32_t blockSize)"
.br
.RI "Initialization function for the Q31 FIR interpolator\&. "
.ti -1c
.RI "void \fBarm_fir_interpolate_f32\fP (const \fBarm_fir_interpolate_instance_f32\fP *S, \fBfloat32_t\fP *pSrc, \fBfloat32_t\fP *pDst, uint32_t blockSize)"
.br
.RI "Processing function for the floating-point FIR interpolator\&. "
.ti -1c
.RI "\fBarm_status\fP \fBarm_fir_interpolate_init_f32\fP (\fBarm_fir_interpolate_instance_f32\fP *S, uint8_t L, uint16_t numTaps, \fBfloat32_t\fP *pCoeffs, \fBfloat32_t\fP *pState, uint32_t blockSize)"
.br
.RI "Initialization function for the floating-point FIR interpolator\&. "
.ti -1c
.RI "void \fBarm_biquad_cas_df1_32x64_q31\fP (const \fBarm_biquad_cas_df1_32x64_ins_q31\fP *S, \fBq31_t\fP *pSrc, \fBq31_t\fP *pDst, uint32_t blockSize)"
.br
.ti -1c
.RI "void \fBarm_biquad_cas_df1_32x64_init_q31\fP (\fBarm_biquad_cas_df1_32x64_ins_q31\fP *S, uint8_t numStages, \fBq31_t\fP *pCoeffs, \fBq63_t\fP *pState, uint8_t postShift)"
.br
.ti -1c
.RI "void \fBarm_biquad_cascade_df2T_f32\fP (const \fBarm_biquad_cascade_df2T_instance_f32\fP *S, \fBfloat32_t\fP *pSrc, \fBfloat32_t\fP *pDst, uint32_t blockSize)"
.br
.RI "Processing function for the floating-point transposed direct form II Biquad cascade filter\&. "
.ti -1c
.RI "void \fBarm_biquad_cascade_stereo_df2T_f32\fP (const \fBarm_biquad_cascade_stereo_df2T_instance_f32\fP *S, \fBfloat32_t\fP *pSrc, \fBfloat32_t\fP *pDst, uint32_t blockSize)"
.br
.RI "Processing function for the floating-point transposed direct form II Biquad cascade filter\&. 2 channels\&. "
.ti -1c
.RI "void \fBarm_biquad_cascade_df2T_f64\fP (const \fBarm_biquad_cascade_df2T_instance_f64\fP *S, \fBfloat64_t\fP *pSrc, \fBfloat64_t\fP *pDst, uint32_t blockSize)"
.br
.RI "Processing function for the floating-point transposed direct form II Biquad cascade filter\&. "
.ti -1c
.RI "void \fBarm_biquad_cascade_df2T_init_f32\fP (\fBarm_biquad_cascade_df2T_instance_f32\fP *S, uint8_t numStages, \fBfloat32_t\fP *pCoeffs, \fBfloat32_t\fP *pState)"
.br
.RI "Initialization function for the floating-point transposed direct form II Biquad cascade filter\&. "
.ti -1c
.RI "void \fBarm_biquad_cascade_stereo_df2T_init_f32\fP (\fBarm_biquad_cascade_stereo_df2T_instance_f32\fP *S, uint8_t numStages, \fBfloat32_t\fP *pCoeffs, \fBfloat32_t\fP *pState)"
.br
.RI "Initialization function for the floating-point transposed direct form II Biquad cascade filter\&. "
.ti -1c
.RI "void \fBarm_biquad_cascade_df2T_init_f64\fP (\fBarm_biquad_cascade_df2T_instance_f64\fP *S, uint8_t numStages, \fBfloat64_t\fP *pCoeffs, \fBfloat64_t\fP *pState)"
.br
.RI "Initialization function for the floating-point transposed direct form II Biquad cascade filter\&. "
.ti -1c
.RI "void \fBarm_fir_lattice_init_q15\fP (\fBarm_fir_lattice_instance_q15\fP *S, uint16_t numStages, \fBq15_t\fP *pCoeffs, \fBq15_t\fP *pState)"
.br
.RI "Initialization function for the Q15 FIR lattice filter\&. "
.ti -1c
.RI "void \fBarm_fir_lattice_q15\fP (const \fBarm_fir_lattice_instance_q15\fP *S, \fBq15_t\fP *pSrc, \fBq15_t\fP *pDst, uint32_t blockSize)"
.br
.RI "Processing function for the Q15 FIR lattice filter\&. "
.ti -1c
.RI "void \fBarm_fir_lattice_init_q31\fP (\fBarm_fir_lattice_instance_q31\fP *S, uint16_t numStages, \fBq31_t\fP *pCoeffs, \fBq31_t\fP *pState)"
.br
.RI "Initialization function for the Q31 FIR lattice filter\&. "
.ti -1c
.RI "void \fBarm_fir_lattice_q31\fP (const \fBarm_fir_lattice_instance_q31\fP *S, \fBq31_t\fP *pSrc, \fBq31_t\fP *pDst, uint32_t blockSize)"
.br
.RI "Processing function for the Q31 FIR lattice filter\&. "
.ti -1c
.RI "void \fBarm_fir_lattice_init_f32\fP (\fBarm_fir_lattice_instance_f32\fP *S, uint16_t numStages, \fBfloat32_t\fP *pCoeffs, \fBfloat32_t\fP *pState)"
.br
.RI "Initialization function for the floating-point FIR lattice filter\&. "
.ti -1c
.RI "void \fBarm_fir_lattice_f32\fP (const \fBarm_fir_lattice_instance_f32\fP *S, \fBfloat32_t\fP *pSrc, \fBfloat32_t\fP *pDst, uint32_t blockSize)"
.br
.RI "Processing function for the floating-point FIR lattice filter\&. "
.ti -1c
.RI "void \fBarm_iir_lattice_f32\fP (const \fBarm_iir_lattice_instance_f32\fP *S, \fBfloat32_t\fP *pSrc, \fBfloat32_t\fP *pDst, uint32_t blockSize)"
.br
.RI "Processing function for the floating-point IIR lattice filter\&. "
.ti -1c
.RI "void \fBarm_iir_lattice_init_f32\fP (\fBarm_iir_lattice_instance_f32\fP *S, uint16_t numStages, \fBfloat32_t\fP *pkCoeffs, \fBfloat32_t\fP *pvCoeffs, \fBfloat32_t\fP *pState, uint32_t blockSize)"
.br
.RI "Initialization function for the floating-point IIR lattice filter\&. "
.ti -1c
.RI "void \fBarm_iir_lattice_q31\fP (const \fBarm_iir_lattice_instance_q31\fP *S, \fBq31_t\fP *pSrc, \fBq31_t\fP *pDst, uint32_t blockSize)"
.br
.RI "Processing function for the Q31 IIR lattice filter\&. "
.ti -1c
.RI "void \fBarm_iir_lattice_init_q31\fP (\fBarm_iir_lattice_instance_q31\fP *S, uint16_t numStages, \fBq31_t\fP *pkCoeffs, \fBq31_t\fP *pvCoeffs, \fBq31_t\fP *pState, uint32_t blockSize)"
.br
.RI "Initialization function for the Q31 IIR lattice filter\&. "
.ti -1c
.RI "void \fBarm_iir_lattice_q15\fP (const \fBarm_iir_lattice_instance_q15\fP *S, \fBq15_t\fP *pSrc, \fBq15_t\fP *pDst, uint32_t blockSize)"
.br
.RI "Processing function for the Q15 IIR lattice filter\&. "
.ti -1c
.RI "void \fBarm_iir_lattice_init_q15\fP (\fBarm_iir_lattice_instance_q15\fP *S, uint16_t numStages, \fBq15_t\fP *pkCoeffs, \fBq15_t\fP *pvCoeffs, \fBq15_t\fP *pState, uint32_t blockSize)"
.br
.RI "Initialization function for the Q15 IIR lattice filter\&. "
.ti -1c
.RI "void \fBarm_lms_f32\fP (const \fBarm_lms_instance_f32\fP *S, \fBfloat32_t\fP *pSrc, \fBfloat32_t\fP *pRef, \fBfloat32_t\fP *pOut, \fBfloat32_t\fP *pErr, uint32_t blockSize)"
.br
.RI "Processing function for floating-point LMS filter\&. "
.ti -1c
.RI "void \fBarm_lms_init_f32\fP (\fBarm_lms_instance_f32\fP *S, uint16_t numTaps, \fBfloat32_t\fP *pCoeffs, \fBfloat32_t\fP *pState, \fBfloat32_t\fP mu, uint32_t blockSize)"
.br
.RI "Initialization function for floating-point LMS filter\&. "
.ti -1c
.RI "void \fBarm_lms_init_q15\fP (\fBarm_lms_instance_q15\fP *S, uint16_t numTaps, \fBq15_t\fP *pCoeffs, \fBq15_t\fP *pState, \fBq15_t\fP mu, uint32_t blockSize, uint32_t postShift)"
.br
.RI "Initialization function for the Q15 LMS filter\&. "
.ti -1c
.RI "void \fBarm_lms_q15\fP (const \fBarm_lms_instance_q15\fP *S, \fBq15_t\fP *pSrc, \fBq15_t\fP *pRef, \fBq15_t\fP *pOut, \fBq15_t\fP *pErr, uint32_t blockSize)"
.br
.RI "Processing function for Q15 LMS filter\&. "
.ti -1c
.RI "void \fBarm_lms_q31\fP (const \fBarm_lms_instance_q31\fP *S, \fBq31_t\fP *pSrc, \fBq31_t\fP *pRef, \fBq31_t\fP *pOut, \fBq31_t\fP *pErr, uint32_t blockSize)"
.br
.RI "Processing function for Q31 LMS filter\&. "
.ti -1c
.RI "void \fBarm_lms_init_q31\fP (\fBarm_lms_instance_q31\fP *S, uint16_t numTaps, \fBq31_t\fP *pCoeffs, \fBq31_t\fP *pState, \fBq31_t\fP mu, uint32_t blockSize, uint32_t postShift)"
.br
.RI "Initialization function for Q31 LMS filter\&. "
.ti -1c
.RI "void \fBarm_lms_norm_f32\fP (\fBarm_lms_norm_instance_f32\fP *S, \fBfloat32_t\fP *pSrc, \fBfloat32_t\fP *pRef, \fBfloat32_t\fP *pOut, \fBfloat32_t\fP *pErr, uint32_t blockSize)"
.br
.RI "Processing function for floating-point normalized LMS filter\&. "
.ti -1c
.RI "void \fBarm_lms_norm_init_f32\fP (\fBarm_lms_norm_instance_f32\fP *S, uint16_t numTaps, \fBfloat32_t\fP *pCoeffs, \fBfloat32_t\fP *pState, \fBfloat32_t\fP mu, uint32_t blockSize)"
.br
.RI "Initialization function for floating-point normalized LMS filter\&. "
.ti -1c
.RI "void \fBarm_lms_norm_q31\fP (\fBarm_lms_norm_instance_q31\fP *S, \fBq31_t\fP *pSrc, \fBq31_t\fP *pRef, \fBq31_t\fP *pOut, \fBq31_t\fP *pErr, uint32_t blockSize)"
.br
.RI "Processing function for Q31 normalized LMS filter\&. "
.ti -1c
.RI "void \fBarm_lms_norm_init_q31\fP (\fBarm_lms_norm_instance_q31\fP *S, uint16_t numTaps, \fBq31_t\fP *pCoeffs, \fBq31_t\fP *pState, \fBq31_t\fP mu, uint32_t blockSize, uint8_t postShift)"
.br
.RI "Initialization function for Q31 normalized LMS filter\&. "
.ti -1c
.RI "void \fBarm_lms_norm_q15\fP (\fBarm_lms_norm_instance_q15\fP *S, \fBq15_t\fP *pSrc, \fBq15_t\fP *pRef, \fBq15_t\fP *pOut, \fBq15_t\fP *pErr, uint32_t blockSize)"
.br
.RI "Processing function for Q15 normalized LMS filter\&. "
.ti -1c
.RI "void \fBarm_lms_norm_init_q15\fP (\fBarm_lms_norm_instance_q15\fP *S, uint16_t numTaps, \fBq15_t\fP *pCoeffs, \fBq15_t\fP *pState, \fBq15_t\fP mu, uint32_t blockSize, uint8_t postShift)"
.br
.RI "Initialization function for Q15 normalized LMS filter\&. "
.ti -1c
.RI "void \fBarm_correlate_f32\fP (\fBfloat32_t\fP *pSrcA, uint32_t srcALen, \fBfloat32_t\fP *pSrcB, uint32_t srcBLen, \fBfloat32_t\fP *pDst)"
.br
.RI "Correlation of floating-point sequences\&. "
.ti -1c
.RI "void \fBarm_correlate_opt_q15\fP (\fBq15_t\fP *pSrcA, uint32_t srcALen, \fBq15_t\fP *pSrcB, uint32_t srcBLen, \fBq15_t\fP *pDst, \fBq15_t\fP *pScratch)"
.br
.RI "Correlation of Q15 sequences\&. "
.ti -1c
.RI "void \fBarm_correlate_q15\fP (\fBq15_t\fP *pSrcA, uint32_t srcALen, \fBq15_t\fP *pSrcB, uint32_t srcBLen, \fBq15_t\fP *pDst)"
.br
.RI "Correlation of Q15 sequences\&. "
.ti -1c
.RI "void \fBarm_correlate_fast_q15\fP (\fBq15_t\fP *pSrcA, uint32_t srcALen, \fBq15_t\fP *pSrcB, uint32_t srcBLen, \fBq15_t\fP *pDst)"
.br
.RI "Correlation of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4\&. "
.ti -1c
.RI "void \fBarm_correlate_fast_opt_q15\fP (\fBq15_t\fP *pSrcA, uint32_t srcALen, \fBq15_t\fP *pSrcB, uint32_t srcBLen, \fBq15_t\fP *pDst, \fBq15_t\fP *pScratch)"
.br
.RI "Correlation of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4\&. "
.ti -1c
.RI "void \fBarm_correlate_q31\fP (\fBq31_t\fP *pSrcA, uint32_t srcALen, \fBq31_t\fP *pSrcB, uint32_t srcBLen, \fBq31_t\fP *pDst)"
.br
.RI "Correlation of Q31 sequences\&. "
.ti -1c
.RI "void \fBarm_correlate_fast_q31\fP (\fBq31_t\fP *pSrcA, uint32_t srcALen, \fBq31_t\fP *pSrcB, uint32_t srcBLen, \fBq31_t\fP *pDst)"
.br
.RI "Correlation of Q31 sequences (fast version) for Cortex-M3 and Cortex-M4\&. "
.ti -1c
.RI "void \fBarm_correlate_opt_q7\fP (\fBq7_t\fP *pSrcA, uint32_t srcALen, \fBq7_t\fP *pSrcB, uint32_t srcBLen, \fBq7_t\fP *pDst, \fBq15_t\fP *pScratch1, \fBq15_t\fP *pScratch2)"
.br
.RI "Correlation of Q7 sequences\&. "
.ti -1c
.RI "void \fBarm_correlate_q7\fP (\fBq7_t\fP *pSrcA, uint32_t srcALen, \fBq7_t\fP *pSrcB, uint32_t srcBLen, \fBq7_t\fP *pDst)"
.br
.RI "Correlation of Q7 sequences\&. "
.ti -1c
.RI "void \fBarm_fir_sparse_f32\fP (\fBarm_fir_sparse_instance_f32\fP *S, \fBfloat32_t\fP *pSrc, \fBfloat32_t\fP *pDst, \fBfloat32_t\fP *pScratchIn, uint32_t blockSize)"
.br
.RI "Processing function for the floating-point sparse FIR filter\&. "
.ti -1c
.RI "void \fBarm_fir_sparse_init_f32\fP (\fBarm_fir_sparse_instance_f32\fP *S, uint16_t numTaps, \fBfloat32_t\fP *pCoeffs, \fBfloat32_t\fP *pState, int32_t *pTapDelay, uint16_t maxDelay, uint32_t blockSize)"
.br
.RI "Initialization function for the floating-point sparse FIR filter\&. "
.ti -1c
.RI "void \fBarm_fir_sparse_q31\fP (\fBarm_fir_sparse_instance_q31\fP *S, \fBq31_t\fP *pSrc, \fBq31_t\fP *pDst, \fBq31_t\fP *pScratchIn, uint32_t blockSize)"
.br
.RI "Processing function for the Q31 sparse FIR filter\&. "
.ti -1c
.RI "void \fBarm_fir_sparse_init_q31\fP (\fBarm_fir_sparse_instance_q31\fP *S, uint16_t numTaps, \fBq31_t\fP *pCoeffs, \fBq31_t\fP *pState, int32_t *pTapDelay, uint16_t maxDelay, uint32_t blockSize)"
.br
.RI "Initialization function for the Q31 sparse FIR filter\&. "
.ti -1c
.RI "void \fBarm_fir_sparse_q15\fP (\fBarm_fir_sparse_instance_q15\fP *S, \fBq15_t\fP *pSrc, \fBq15_t\fP *pDst, \fBq15_t\fP *pScratchIn, \fBq31_t\fP *pScratchOut, uint32_t blockSize)"
.br
.RI "Processing function for the Q15 sparse FIR filter\&. "
.ti -1c
.RI "void \fBarm_fir_sparse_init_q15\fP (\fBarm_fir_sparse_instance_q15\fP *S, uint16_t numTaps, \fBq15_t\fP *pCoeffs, \fBq15_t\fP *pState, int32_t *pTapDelay, uint16_t maxDelay, uint32_t blockSize)"
.br
.RI "Initialization function for the Q15 sparse FIR filter\&. "
.ti -1c
.RI "void \fBarm_fir_sparse_q7\fP (\fBarm_fir_sparse_instance_q7\fP *S, \fBq7_t\fP *pSrc, \fBq7_t\fP *pDst, \fBq7_t\fP *pScratchIn, \fBq31_t\fP *pScratchOut, uint32_t blockSize)"
.br
.RI "Processing function for the Q7 sparse FIR filter\&. "
.ti -1c
.RI "void \fBarm_fir_sparse_init_q7\fP (\fBarm_fir_sparse_instance_q7\fP *S, uint16_t numTaps, \fBq7_t\fP *pCoeffs, \fBq7_t\fP *pState, int32_t *pTapDelay, uint16_t maxDelay, uint32_t blockSize)"
.br
.RI "Initialization function for the Q7 sparse FIR filter\&. "
.ti -1c
.RI "void \fBarm_sin_cos_f32\fP (\fBfloat32_t\fP theta, \fBfloat32_t\fP *pSinVal, \fBfloat32_t\fP *pCosVal)"
.br
.RI "Floating-point sin_cos function\&. "
.ti -1c
.RI "void \fBarm_sin_cos_q31\fP (\fBq31_t\fP theta, \fBq31_t\fP *pSinVal, \fBq31_t\fP *pCosVal)"
.br
.RI "Q31 sin_cos function\&. "
.ti -1c
.RI "void \fBarm_cmplx_conj_f32\fP (\fBfloat32_t\fP *pSrc, \fBfloat32_t\fP *pDst, uint32_t numSamples)"
.br
.RI "Floating-point complex conjugate\&. "
.ti -1c
.RI "void \fBarm_cmplx_conj_q31\fP (\fBq31_t\fP *pSrc, \fBq31_t\fP *pDst, uint32_t numSamples)"
.br
.RI "Q31 complex conjugate\&. "
.ti -1c
.RI "void \fBarm_cmplx_conj_q15\fP (\fBq15_t\fP *pSrc, \fBq15_t\fP *pDst, uint32_t numSamples)"
.br
.RI "Q15 complex conjugate\&. "
.ti -1c
.RI "void \fBarm_cmplx_mag_squared_f32\fP (\fBfloat32_t\fP *pSrc, \fBfloat32_t\fP *pDst, uint32_t numSamples)"
.br
.RI "Floating-point complex magnitude squared\&. "
.ti -1c
.RI "void \fBarm_cmplx_mag_squared_q31\fP (\fBq31_t\fP *pSrc, \fBq31_t\fP *pDst, uint32_t numSamples)"
.br
.RI "Q31 complex magnitude squared\&. "
.ti -1c
.RI "void \fBarm_cmplx_mag_squared_q15\fP (\fBq15_t\fP *pSrc, \fBq15_t\fP *pDst, uint32_t numSamples)"
.br
.RI "Q15 complex magnitude squared\&. "
.ti -1c
.RI "\fBarm_status\fP \fBarm_mat_inverse_f32\fP (const \fBarm_matrix_instance_f32\fP *src, \fBarm_matrix_instance_f32\fP *dst)"
.br
.RI "Floating-point matrix inverse\&. "
.ti -1c
.RI "\fBarm_status\fP \fBarm_mat_inverse_f64\fP (const \fBarm_matrix_instance_f64\fP *src, \fBarm_matrix_instance_f64\fP *dst)"
.br
.RI "Floating-point matrix inverse\&. "
.ti -1c
.RI "void \fBarm_q7_to_q31\fP (\fBq7_t\fP *pSrc, \fBq31_t\fP *pDst, uint32_t blockSize)"
.br
.RI "Converts the elements of the Q7 vector to Q31 vector\&. "
.ti -1c
.RI "void \fBarm_q7_to_q15\fP (\fBq7_t\fP *pSrc, \fBq15_t\fP *pDst, uint32_t blockSize)"
.br
.RI "Converts the elements of the Q7 vector to Q15 vector\&. "
.ti -1c
.RI "void \fBarm_q7_to_float\fP (\fBq7_t\fP *pSrc, \fBfloat32_t\fP *pDst, uint32_t blockSize)"
.br
.RI "Converts the elements of the Q7 vector to floating-point vector\&. "
.ti -1c
.RI "void \fBarm_q31_to_float\fP (\fBq31_t\fP *pSrc, \fBfloat32_t\fP *pDst, uint32_t blockSize)"
.br
.RI "Converts the elements of the Q31 vector to floating-point vector\&. "
.ti -1c
.RI "\fBfloat32_t\fP \fBarm_sin_f32\fP (\fBfloat32_t\fP x)"
.br
.RI "Fast approximation to the trigonometric sine function for floating-point data\&. "
.ti -1c
.RI "\fBq31_t\fP \fBarm_sin_q31\fP (\fBq31_t\fP x)"
.br
.RI "Fast approximation to the trigonometric sine function for Q31 data\&. "
.ti -1c
.RI "\fBq15_t\fP \fBarm_sin_q15\fP (\fBq15_t\fP x)"
.br
.RI "Fast approximation to the trigonometric sine function for Q15 data\&. "
.ti -1c
.RI "\fBfloat32_t\fP \fBarm_cos_f32\fP (\fBfloat32_t\fP x)"
.br
.RI "Fast approximation to the trigonometric cosine function for floating-point data\&. "
.ti -1c
.RI "\fBq31_t\fP \fBarm_cos_q31\fP (\fBq31_t\fP x)"
.br
.RI "Fast approximation to the trigonometric cosine function for Q31 data\&. "
.ti -1c
.RI "\fBq15_t\fP \fBarm_cos_q15\fP (\fBq15_t\fP x)"
.br
.RI "Fast approximation to the trigonometric cosine function for Q15 data\&. "
.ti -1c
.RI "\fBarm_status\fP \fBarm_sqrt_q31\fP (\fBq31_t\fP in, \fBq31_t\fP *pOut)"
.br
.RI "Q31 square root function\&. "
.ti -1c
.RI "\fBarm_status\fP \fBarm_sqrt_q15\fP (\fBq15_t\fP in, \fBq15_t\fP *pOut)"
.br
.RI "Q15 square root function\&. "
.ti -1c
.RI "void \fBarm_power_q31\fP (\fBq31_t\fP *pSrc, uint32_t blockSize, \fBq63_t\fP *pResult)"
.br
.RI "Sum of the squares of the elements of a Q31 vector\&. "
.ti -1c
.RI "void \fBarm_power_f32\fP (\fBfloat32_t\fP *pSrc, uint32_t blockSize, \fBfloat32_t\fP *pResult)"
.br
.RI "Sum of the squares of the elements of a floating-point vector\&. "
.ti -1c
.RI "void \fBarm_power_q15\fP (\fBq15_t\fP *pSrc, uint32_t blockSize, \fBq63_t\fP *pResult)"
.br
.RI "Sum of the squares of the elements of a Q15 vector\&. "
.ti -1c
.RI "void \fBarm_power_q7\fP (\fBq7_t\fP *pSrc, uint32_t blockSize, \fBq31_t\fP *pResult)"
.br
.RI "Sum of the squares of the elements of a Q7 vector\&. "
.ti -1c
.RI "void \fBarm_mean_q7\fP (\fBq7_t\fP *pSrc, uint32_t blockSize, \fBq7_t\fP *pResult)"
.br
.RI "Mean value of a Q7 vector\&. "
.ti -1c
.RI "void \fBarm_mean_q15\fP (\fBq15_t\fP *pSrc, uint32_t blockSize, \fBq15_t\fP *pResult)"
.br
.RI "Mean value of a Q15 vector\&. "
.ti -1c
.RI "void \fBarm_mean_q31\fP (\fBq31_t\fP *pSrc, uint32_t blockSize, \fBq31_t\fP *pResult)"
.br
.RI "Mean value of a Q31 vector\&. "
.ti -1c
.RI "void \fBarm_mean_f32\fP (\fBfloat32_t\fP *pSrc, uint32_t blockSize, \fBfloat32_t\fP *pResult)"
.br
.RI "Mean value of a floating-point vector\&. "
.ti -1c
.RI "void \fBarm_var_f32\fP (\fBfloat32_t\fP *pSrc, uint32_t blockSize, \fBfloat32_t\fP *pResult)"
.br
.RI "Variance of the elements of a floating-point vector\&. "
.ti -1c
.RI "void \fBarm_var_q31\fP (\fBq31_t\fP *pSrc, uint32_t blockSize, \fBq31_t\fP *pResult)"
.br
.RI "Variance of the elements of a Q31 vector\&. "
.ti -1c
.RI "void \fBarm_var_q15\fP (\fBq15_t\fP *pSrc, uint32_t blockSize, \fBq15_t\fP *pResult)"
.br
.RI "Variance of the elements of a Q15 vector\&. "
.ti -1c
.RI "void \fBarm_rms_f32\fP (\fBfloat32_t\fP *pSrc, uint32_t blockSize, \fBfloat32_t\fP *pResult)"
.br
.RI "Root Mean Square of the elements of a floating-point vector\&. "
.ti -1c
.RI "void \fBarm_rms_q31\fP (\fBq31_t\fP *pSrc, uint32_t blockSize, \fBq31_t\fP *pResult)"
.br
.RI "Root Mean Square of the elements of a Q31 vector\&. "
.ti -1c
.RI "void \fBarm_rms_q15\fP (\fBq15_t\fP *pSrc, uint32_t blockSize, \fBq15_t\fP *pResult)"
.br
.RI "Root Mean Square of the elements of a Q15 vector\&. "
.ti -1c
.RI "void \fBarm_std_f32\fP (\fBfloat32_t\fP *pSrc, uint32_t blockSize, \fBfloat32_t\fP *pResult)"
.br
.RI "Standard deviation of the elements of a floating-point vector\&. "
.ti -1c
.RI "void \fBarm_std_q31\fP (\fBq31_t\fP *pSrc, uint32_t blockSize, \fBq31_t\fP *pResult)"
.br
.RI "Standard deviation of the elements of a Q31 vector\&. "
.ti -1c
.RI "void \fBarm_std_q15\fP (\fBq15_t\fP *pSrc, uint32_t blockSize, \fBq15_t\fP *pResult)"
.br
.RI "Standard deviation of the elements of a Q15 vector\&. "
.ti -1c
.RI "void \fBarm_cmplx_mag_f32\fP (\fBfloat32_t\fP *pSrc, \fBfloat32_t\fP *pDst, uint32_t numSamples)"
.br
.RI "Floating-point complex magnitude\&. "
.ti -1c
.RI "void \fBarm_cmplx_mag_q31\fP (\fBq31_t\fP *pSrc, \fBq31_t\fP *pDst, uint32_t numSamples)"
.br
.RI "Q31 complex magnitude\&. "
.ti -1c
.RI "void \fBarm_cmplx_mag_q15\fP (\fBq15_t\fP *pSrc, \fBq15_t\fP *pDst, uint32_t numSamples)"
.br
.RI "Q15 complex magnitude\&. "
.ti -1c
.RI "void \fBarm_cmplx_dot_prod_q15\fP (\fBq15_t\fP *pSrcA, \fBq15_t\fP *pSrcB, uint32_t numSamples, \fBq31_t\fP *realResult, \fBq31_t\fP *imagResult)"
.br
.RI "Q15 complex dot product\&. "
.ti -1c
.RI "void \fBarm_cmplx_dot_prod_q31\fP (\fBq31_t\fP *pSrcA, \fBq31_t\fP *pSrcB, uint32_t numSamples, \fBq63_t\fP *realResult, \fBq63_t\fP *imagResult)"
.br
.RI "Q31 complex dot product\&. "
.ti -1c
.RI "void \fBarm_cmplx_dot_prod_f32\fP (\fBfloat32_t\fP *pSrcA, \fBfloat32_t\fP *pSrcB, uint32_t numSamples, \fBfloat32_t\fP *realResult, \fBfloat32_t\fP *imagResult)"
.br
.RI "Floating-point complex dot product\&. "
.ti -1c
.RI "void \fBarm_cmplx_mult_real_q15\fP (\fBq15_t\fP *pSrcCmplx, \fBq15_t\fP *pSrcReal, \fBq15_t\fP *pCmplxDst, uint32_t numSamples)"
.br
.RI "Q15 complex-by-real multiplication\&. "
.ti -1c
.RI "void \fBarm_cmplx_mult_real_q31\fP (\fBq31_t\fP *pSrcCmplx, \fBq31_t\fP *pSrcReal, \fBq31_t\fP *pCmplxDst, uint32_t numSamples)"
.br
.RI "Q31 complex-by-real multiplication\&. "
.ti -1c
.RI "void \fBarm_cmplx_mult_real_f32\fP (\fBfloat32_t\fP *pSrcCmplx, \fBfloat32_t\fP *pSrcReal, \fBfloat32_t\fP *pCmplxDst, uint32_t numSamples)"
.br
.RI "Floating-point complex-by-real multiplication\&. "
.ti -1c
.RI "void \fBarm_min_q7\fP (\fBq7_t\fP *pSrc, uint32_t blockSize, \fBq7_t\fP *result, uint32_t *index)"
.br
.RI "Minimum value of a Q7 vector\&. "
.ti -1c
.RI "void \fBarm_min_q15\fP (\fBq15_t\fP *pSrc, uint32_t blockSize, \fBq15_t\fP *pResult, uint32_t *pIndex)"
.br
.RI "Minimum value of a Q15 vector\&. "
.ti -1c
.RI "void \fBarm_min_q31\fP (\fBq31_t\fP *pSrc, uint32_t blockSize, \fBq31_t\fP *pResult, uint32_t *pIndex)"
.br
.RI "Minimum value of a Q31 vector\&. "
.ti -1c
.RI "void \fBarm_min_f32\fP (\fBfloat32_t\fP *pSrc, uint32_t blockSize, \fBfloat32_t\fP *pResult, uint32_t *pIndex)"
.br
.RI "Minimum value of a floating-point vector\&. "
.ti -1c
.RI "void \fBarm_max_q7\fP (\fBq7_t\fP *pSrc, uint32_t blockSize, \fBq7_t\fP *pResult, uint32_t *pIndex)"
.br
.RI "Maximum value of a Q7 vector\&. "
.ti -1c
.RI "void \fBarm_max_q15\fP (\fBq15_t\fP *pSrc, uint32_t blockSize, \fBq15_t\fP *pResult, uint32_t *pIndex)"
.br
.RI "Maximum value of a Q15 vector\&. "
.ti -1c
.RI "void \fBarm_max_q31\fP (\fBq31_t\fP *pSrc, uint32_t blockSize, \fBq31_t\fP *pResult, uint32_t *pIndex)"
.br
.RI "Maximum value of a Q31 vector\&. "
.ti -1c
.RI "void \fBarm_max_f32\fP (\fBfloat32_t\fP *pSrc, uint32_t blockSize, \fBfloat32_t\fP *pResult, uint32_t *pIndex)"
.br
.RI "Maximum value of a floating-point vector\&. "
.ti -1c
.RI "void \fBarm_cmplx_mult_cmplx_q15\fP (\fBq15_t\fP *pSrcA, \fBq15_t\fP *pSrcB, \fBq15_t\fP *pDst, uint32_t numSamples)"
.br
.RI "Q15 complex-by-complex multiplication\&. "
.ti -1c
.RI "void \fBarm_cmplx_mult_cmplx_q31\fP (\fBq31_t\fP *pSrcA, \fBq31_t\fP *pSrcB, \fBq31_t\fP *pDst, uint32_t numSamples)"
.br
.RI "Q31 complex-by-complex multiplication\&. "
.ti -1c
.RI "void \fBarm_cmplx_mult_cmplx_f32\fP (\fBfloat32_t\fP *pSrcA, \fBfloat32_t\fP *pSrcB, \fBfloat32_t\fP *pDst, uint32_t numSamples)"
.br
.RI "Floating-point complex-by-complex multiplication\&. "
.ti -1c
.RI "void \fBarm_float_to_q31\fP (\fBfloat32_t\fP *pSrc, \fBq31_t\fP *pDst, uint32_t blockSize)"
.br
.RI "Converts the elements of the floating-point vector to Q31 vector\&. "
.ti -1c
.RI "void \fBarm_float_to_q15\fP (\fBfloat32_t\fP *pSrc, \fBq15_t\fP *pDst, uint32_t blockSize)"
.br
.RI "Converts the elements of the floating-point vector to Q15 vector\&. "
.ti -1c
.RI "void \fBarm_float_to_q7\fP (\fBfloat32_t\fP *pSrc, \fBq7_t\fP *pDst, uint32_t blockSize)"
.br
.RI "Converts the elements of the floating-point vector to Q7 vector\&. "
.ti -1c
.RI "void \fBarm_q31_to_q15\fP (\fBq31_t\fP *pSrc, \fBq15_t\fP *pDst, uint32_t blockSize)"
.br
.RI "Converts the elements of the Q31 vector to Q15 vector\&. "
.ti -1c
.RI "void \fBarm_q31_to_q7\fP (\fBq31_t\fP *pSrc, \fBq7_t\fP *pDst, uint32_t blockSize)"
.br
.RI "Converts the elements of the Q31 vector to Q7 vector\&. "
.ti -1c
.RI "void \fBarm_q15_to_float\fP (\fBq15_t\fP *pSrc, \fBfloat32_t\fP *pDst, uint32_t blockSize)"
.br
.RI "Converts the elements of the Q15 vector to floating-point vector\&. "
.ti -1c
.RI "void \fBarm_q15_to_q31\fP (\fBq15_t\fP *pSrc, \fBq31_t\fP *pDst, uint32_t blockSize)"
.br
.RI "Converts the elements of the Q15 vector to Q31 vector\&. "
.ti -1c
.RI "void \fBarm_q15_to_q7\fP (\fBq15_t\fP *pSrc, \fBq7_t\fP *pDst, uint32_t blockSize)"
.br
.RI "Converts the elements of the Q15 vector to Q7 vector\&. "
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define __CMSIS_GENERIC   /* disable \fBNVIC\fP and Systick functions */"

.PP
Definition at line 299 of file arm_math\&.h\&.
.SS "#define __PACKq7(v0, v1, v2, v3)"
\fBValue:\fP
.PP
.nf
( (((int32_t)(v0) <<  0) & (int32_t)0x000000FF) | \
                                (((int32_t)(v1) <<  8) & (int32_t)0x0000FF00) | \
                                (((int32_t)(v2) << 16) & (int32_t)0x00FF0000) | \
                                (((int32_t)(v3) << 24) & (int32_t)0xFF000000)  )
.fi
.PP
definition to pack four 8 bit values\&. 
.PP
Definition at line 467 of file arm_math\&.h\&.
.SS "#define __SIMD32(addr)   (*(__SIMD32_TYPE **) & (addr))"

.PP
definition to read/write two 16 bit values\&. 
.PP
Definition at line 445 of file arm_math\&.h\&.
.SS "#define __SIMD32_CONST(addr)   ((__SIMD32_TYPE *)(addr))"

.PP
Definition at line 446 of file arm_math\&.h\&.
.SS "#define __SIMD64(addr)   (*(int64_t **) & (addr))"

.PP
Definition at line 448 of file arm_math\&.h\&.
.SS "#define _SIMD32_OFFSET(addr)   (*(__SIMD32_TYPE *)  (addr))"

.PP
Definition at line 447 of file arm_math\&.h\&.
.SS "#define ALIGN4"

.PP
Macro for Unaligned Support\&. 
.PP
Definition at line 360 of file arm_math\&.h\&.
.SS "#define CONTROLLER_Q31_SHIFT   (32 \- 9)"

.PP
Definition at line 344 of file arm_math\&.h\&.
.SS "#define DELTA_Q15   0x5"

.PP
Definition at line 331 of file arm_math\&.h\&.
.SS "#define DELTA_Q31   (0x100)"

.PP
Macros required for reciprocal calculation in Normalized LMS\&. 
.PP
Definition at line 330 of file arm_math\&.h\&.
.SS "#define FAST_MATH_Q15_SHIFT   (16 \- 10)"

.PP
Definition at line 343 of file arm_math\&.h\&.
.SS "#define FAST_MATH_Q31_SHIFT   (32 \- 10)"

.PP
Definition at line 342 of file arm_math\&.h\&.
.SS "#define FAST_MATH_TABLE_SIZE   512"

.PP
Macros required for SINE and COSINE Fast math approximations\&. 
.PP
Definition at line 341 of file arm_math\&.h\&.
.SS "#define INDEX_MASK   0x0000003F"

.PP
Definition at line 332 of file arm_math\&.h\&.
.SS "#define INPUT_SPACING   0xB60B61"

.PP
Macros required for SINE and COSINE Controller functions\&. 
.PP
Definition at line 354 of file arm_math\&.h\&.
.SS "#define mult_32x32_keep32(a, x, y)   a = (\fBq31_t\fP) (((\fBq63_t\fP) x * y ) >> 32)"

.PP
Definition at line 7062 of file arm_math\&.h\&.
.SS "#define mult_32x32_keep32_R(a, x, y)   a = (\fBq31_t\fP) (((\fBq63_t\fP) x * y + 0x80000000LL ) >> 32)"

.PP
Definition at line 7050 of file arm_math\&.h\&.
.SS "#define multAcc_32x32_keep32(a, x, y)   a += (\fBq31_t\fP) (((\fBq63_t\fP) x * y) >> 32)"

.PP
Definition at line 7054 of file arm_math\&.h\&.
.SS "#define multAcc_32x32_keep32_R(a, x, y)   a = (\fBq31_t\fP) (((((\fBq63_t\fP) a) << 32) + ((\fBq63_t\fP) x * y) + 0x80000000LL ) >> 32)"
end of BilinearInterpolate group 
.PP
Definition at line 7042 of file arm_math\&.h\&.
.SS "#define multSub_32x32_keep32(a, x, y)   a \-= (\fBq31_t\fP) (((\fBq63_t\fP) x * y) >> 32)"

.PP
Definition at line 7058 of file arm_math\&.h\&.
.SS "#define multSub_32x32_keep32_R(a, x, y)   a = (\fBq31_t\fP) (((((\fBq63_t\fP) a) << 32) \- ((\fBq63_t\fP) x * y) + 0x80000000LL ) >> 32)"

.PP
Definition at line 7046 of file arm_math\&.h\&.
.SS "#define PI   3\&.14159265358979f"

.PP
Definition at line 334 of file arm_math\&.h\&.
.SS "#define TABLE_SIZE   256"

.PP
Definition at line 345 of file arm_math\&.h\&.
.SS "#define TABLE_SPACING_Q15   0x80"

.PP
Definition at line 347 of file arm_math\&.h\&.
.SS "#define TABLE_SPACING_Q31   0x400000"

.PP
Definition at line 346 of file arm_math\&.h\&.
.SH "Typedef Documentation"
.PP 
.SS "typedef float \fBfloat32_t\fP"

.PP
32-bit floating-point type definition\&. 
.PP
Definition at line 407 of file arm_math\&.h\&.
.SS "typedef double \fBfloat64_t\fP"

.PP
64-bit floating-point type definition\&. 
.PP
Definition at line 412 of file arm_math\&.h\&.
.SS "typedef int16_t \fBq15_t\fP"

.PP
16-bit fractional data type in 1\&.15 format\&. 
.PP
Definition at line 392 of file arm_math\&.h\&.
.SS "typedef int32_t \fBq31_t\fP"

.PP
32-bit fractional data type in 1\&.31 format\&. 
.PP
Definition at line 397 of file arm_math\&.h\&.
.SS "typedef int64_t \fBq63_t\fP"

.PP
64-bit fractional data type in 1\&.63 format\&. 
.PP
Definition at line 402 of file arm_math\&.h\&.
.SS "typedef int8_t \fBq7_t\fP"

.PP
8-bit fractional data type in 1\&.7 format\&. 
.PP
Definition at line 387 of file arm_math\&.h\&.
.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBarm_status\fP"

.PP
Error status returned by some functions in the library\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIARM_MATH_SUCCESS \fP\fP
No error 
.TP
\fB\fIARM_MATH_ARGUMENT_ERROR \fP\fP
One or more arguments are incorrect 
.TP
\fB\fIARM_MATH_LENGTH_ERROR \fP\fP
Length of data buffer is incorrect 
.TP
\fB\fIARM_MATH_SIZE_MISMATCH \fP\fP
Size of matrices is not compatible with the operation\&. 
.TP
\fB\fIARM_MATH_NANINF \fP\fP
Not-a-number (NaN) or infinity is generated 
.TP
\fB\fIARM_MATH_SINGULAR \fP\fP
Generated by matrix inversion if the input matrix is singular and cannot be inverted\&. 
.TP
\fB\fIARM_MATH_TEST_FAILURE \fP\fP
Test Failed 
.PP
Definition at line 373 of file arm_math\&.h\&.
.SH "Function Documentation"
.PP 
.SS "void arm_abs_f32 (\fBfloat32_t\fP * pSrc, \fBfloat32_t\fP * pDst, uint32_t blockSize)"

.PP
Floating-point vector absolute value\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrc\fP points to the input buffer 
.br
\fIpDst\fP points to the output buffer 
.br
\fIblockSize\fP number of samples in each vector 
.RE
.PP

.SS "void arm_abs_q15 (\fBq15_t\fP * pSrc, \fBq15_t\fP * pDst, uint32_t blockSize)"

.PP
Q15 vector absolute value\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrc\fP points to the input buffer 
.br
\fIpDst\fP points to the output buffer 
.br
\fIblockSize\fP number of samples in each vector 
.RE
.PP

.SS "void arm_abs_q31 (\fBq31_t\fP * pSrc, \fBq31_t\fP * pDst, uint32_t blockSize)"

.PP
Q31 vector absolute value\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrc\fP points to the input buffer 
.br
\fIpDst\fP points to the output buffer 
.br
\fIblockSize\fP number of samples in each vector 
.RE
.PP

.SS "void arm_abs_q7 (\fBq7_t\fP * pSrc, \fBq7_t\fP * pDst, uint32_t blockSize)"

.PP
Q7 vector absolute value\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrc\fP points to the input buffer 
.br
\fIpDst\fP points to the output buffer 
.br
\fIblockSize\fP number of samples in each vector 
.RE
.PP

.SS "void arm_add_f32 (\fBfloat32_t\fP * pSrcA, \fBfloat32_t\fP * pSrcB, \fBfloat32_t\fP * pDst, uint32_t blockSize)"

.PP
Floating-point vector addition\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrcA\fP points to the first input vector 
.br
\fIpSrcB\fP points to the second input vector 
.br
\fIpDst\fP points to the output vector 
.br
\fIblockSize\fP number of samples in each vector 
.RE
.PP

.SS "void arm_add_q15 (\fBq15_t\fP * pSrcA, \fBq15_t\fP * pSrcB, \fBq15_t\fP * pDst, uint32_t blockSize)"

.PP
Q15 vector addition\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrcA\fP points to the first input vector 
.br
\fIpSrcB\fP points to the second input vector 
.br
\fIpDst\fP points to the output vector 
.br
\fIblockSize\fP number of samples in each vector 
.RE
.PP

.SS "void arm_add_q31 (\fBq31_t\fP * pSrcA, \fBq31_t\fP * pSrcB, \fBq31_t\fP * pDst, uint32_t blockSize)"

.PP
Q31 vector addition\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrcA\fP points to the first input vector 
.br
\fIpSrcB\fP points to the second input vector 
.br
\fIpDst\fP points to the output vector 
.br
\fIblockSize\fP number of samples in each vector 
.RE
.PP

.SS "void arm_add_q7 (\fBq7_t\fP * pSrcA, \fBq7_t\fP * pSrcB, \fBq7_t\fP * pDst, uint32_t blockSize)"

.PP
Q7 vector addition\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrcA\fP points to the first input vector 
.br
\fIpSrcB\fP points to the second input vector 
.br
\fIpDst\fP points to the output vector 
.br
\fIblockSize\fP number of samples in each vector 
.RE
.PP

.SS "void arm_biquad_cas_df1_32x64_init_q31 (\fBarm_biquad_cas_df1_32x64_ins_q31\fP * S, uint8_t numStages, \fBq31_t\fP * pCoeffs, \fBq63_t\fP * pState, uint8_t postShift)"

.PP
\fBParameters:\fP
.RS 4
\fIS\fP points to an instance of the high precision Q31 Biquad cascade filter structure\&. 
.br
\fInumStages\fP number of 2nd order stages in the filter\&. 
.br
\fIpCoeffs\fP points to the filter coefficients\&. 
.br
\fIpState\fP points to the state buffer\&. 
.br
\fIpostShift\fP shift to be applied to the output\&. Varies according to the coefficients format 
.RE
.PP

.SS "void arm_biquad_cas_df1_32x64_q31 (const \fBarm_biquad_cas_df1_32x64_ins_q31\fP * S, \fBq31_t\fP * pSrc, \fBq31_t\fP * pDst, uint32_t blockSize)"

.PP
\fBParameters:\fP
.RS 4
\fIS\fP points to an instance of the high precision Q31 Biquad cascade filter structure\&. 
.br
\fIpSrc\fP points to the block of input data\&. 
.br
\fIpDst\fP points to the block of output data 
.br
\fIblockSize\fP number of samples to process\&. 
.RE
.PP

.SS "void arm_biquad_cascade_df1_f32 (const \fBarm_biquad_casd_df1_inst_f32\fP * S, \fBfloat32_t\fP * pSrc, \fBfloat32_t\fP * pDst, uint32_t blockSize)"

.PP
Processing function for the floating-point Biquad cascade filter\&. 
.PP
\fBParameters:\fP
.RS 4
\fIS\fP points to an instance of the floating-point Biquad cascade structure\&. 
.br
\fIpSrc\fP points to the block of input data\&. 
.br
\fIpDst\fP points to the block of output data\&. 
.br
\fIblockSize\fP number of samples to process\&. 
.RE
.PP

.SS "void arm_biquad_cascade_df1_fast_q15 (const \fBarm_biquad_casd_df1_inst_q15\fP * S, \fBq15_t\fP * pSrc, \fBq15_t\fP * pDst, uint32_t blockSize)"

.PP
Fast but less precise processing function for the Q15 Biquad cascade filter for Cortex-M3 and Cortex-M4\&. 
.PP
\fBParameters:\fP
.RS 4
\fIS\fP points to an instance of the Q15 Biquad cascade structure\&. 
.br
\fIpSrc\fP points to the block of input data\&. 
.br
\fIpDst\fP points to the block of output data\&. 
.br
\fIblockSize\fP number of samples to process\&. 
.RE
.PP

.SS "void arm_biquad_cascade_df1_fast_q31 (const \fBarm_biquad_casd_df1_inst_q31\fP * S, \fBq31_t\fP * pSrc, \fBq31_t\fP * pDst, uint32_t blockSize)"

.PP
Fast but less precise processing function for the Q31 Biquad cascade filter for Cortex-M3 and Cortex-M4\&. 
.PP
\fBParameters:\fP
.RS 4
\fIS\fP points to an instance of the Q31 Biquad cascade structure\&. 
.br
\fIpSrc\fP points to the block of input data\&. 
.br
\fIpDst\fP points to the block of output data\&. 
.br
\fIblockSize\fP number of samples to process\&. 
.RE
.PP

.SS "void arm_biquad_cascade_df1_init_f32 (\fBarm_biquad_casd_df1_inst_f32\fP * S, uint8_t numStages, \fBfloat32_t\fP * pCoeffs, \fBfloat32_t\fP * pState)"

.PP
Initialization function for the floating-point Biquad cascade filter\&. 
.PP
\fBParameters:\fP
.RS 4
\fIS\fP points to an instance of the floating-point Biquad cascade structure\&. 
.br
\fInumStages\fP number of 2nd order stages in the filter\&. 
.br
\fIpCoeffs\fP points to the filter coefficients\&. 
.br
\fIpState\fP points to the state buffer\&. 
.RE
.PP

.SS "void arm_biquad_cascade_df1_init_q15 (\fBarm_biquad_casd_df1_inst_q15\fP * S, uint8_t numStages, \fBq15_t\fP * pCoeffs, \fBq15_t\fP * pState, int8_t postShift)"

.PP
Initialization function for the Q15 Biquad cascade filter\&. 
.PP
\fBParameters:\fP
.RS 4
\fIS\fP points to an instance of the Q15 Biquad cascade structure\&. 
.br
\fInumStages\fP number of 2nd order stages in the filter\&. 
.br
\fIpCoeffs\fP points to the filter coefficients\&. 
.br
\fIpState\fP points to the state buffer\&. 
.br
\fIpostShift\fP Shift to be applied to the output\&. Varies according to the coefficients format 
.RE
.PP

.SS "void arm_biquad_cascade_df1_init_q31 (\fBarm_biquad_casd_df1_inst_q31\fP * S, uint8_t numStages, \fBq31_t\fP * pCoeffs, \fBq31_t\fP * pState, int8_t postShift)"

.PP
Initialization function for the Q31 Biquad cascade filter\&. 
.PP
\fBParameters:\fP
.RS 4
\fIS\fP points to an instance of the Q31 Biquad cascade structure\&. 
.br
\fInumStages\fP number of 2nd order stages in the filter\&. 
.br
\fIpCoeffs\fP points to the filter coefficients\&. 
.br
\fIpState\fP points to the state buffer\&. 
.br
\fIpostShift\fP Shift to be applied to the output\&. Varies according to the coefficients format 
.RE
.PP

.SS "void arm_biquad_cascade_df1_q15 (const \fBarm_biquad_casd_df1_inst_q15\fP * S, \fBq15_t\fP * pSrc, \fBq15_t\fP * pDst, uint32_t blockSize)"

.PP
Processing function for the Q15 Biquad cascade filter\&. 
.PP
\fBParameters:\fP
.RS 4
\fIS\fP points to an instance of the Q15 Biquad cascade structure\&. 
.br
\fIpSrc\fP points to the block of input data\&. 
.br
\fIpDst\fP points to the block of output data\&. 
.br
\fIblockSize\fP number of samples to process\&. 
.RE
.PP

.SS "void arm_biquad_cascade_df1_q31 (const \fBarm_biquad_casd_df1_inst_q31\fP * S, \fBq31_t\fP * pSrc, \fBq31_t\fP * pDst, uint32_t blockSize)"

.PP
Processing function for the Q31 Biquad cascade filter\&. 
.PP
\fBParameters:\fP
.RS 4
\fIS\fP points to an instance of the Q31 Biquad cascade structure\&. 
.br
\fIpSrc\fP points to the block of input data\&. 
.br
\fIpDst\fP points to the block of output data\&. 
.br
\fIblockSize\fP number of samples to process\&. 
.RE
.PP

.SS "void arm_biquad_cascade_df2T_f32 (const \fBarm_biquad_cascade_df2T_instance_f32\fP * S, \fBfloat32_t\fP * pSrc, \fBfloat32_t\fP * pDst, uint32_t blockSize)"

.PP
Processing function for the floating-point transposed direct form II Biquad cascade filter\&. 
.PP
\fBParameters:\fP
.RS 4
\fIS\fP points to an instance of the filter data structure\&. 
.br
\fIpSrc\fP points to the block of input data\&. 
.br
\fIpDst\fP points to the block of output data 
.br
\fIblockSize\fP number of samples to process\&. 
.RE
.PP

.SS "void arm_biquad_cascade_df2T_f64 (const \fBarm_biquad_cascade_df2T_instance_f64\fP * S, \fBfloat64_t\fP * pSrc, \fBfloat64_t\fP * pDst, uint32_t blockSize)"

.PP
Processing function for the floating-point transposed direct form II Biquad cascade filter\&. 
.PP
\fBParameters:\fP
.RS 4
\fIS\fP points to an instance of the filter data structure\&. 
.br
\fIpSrc\fP points to the block of input data\&. 
.br
\fIpDst\fP points to the block of output data 
.br
\fIblockSize\fP number of samples to process\&. 
.RE
.PP

.SS "void arm_biquad_cascade_df2T_init_f32 (\fBarm_biquad_cascade_df2T_instance_f32\fP * S, uint8_t numStages, \fBfloat32_t\fP * pCoeffs, \fBfloat32_t\fP * pState)"

.PP
Initialization function for the floating-point transposed direct form II Biquad cascade filter\&. 
.PP
\fBParameters:\fP
.RS 4
\fIS\fP points to an instance of the filter data structure\&. 
.br
\fInumStages\fP number of 2nd order stages in the filter\&. 
.br
\fIpCoeffs\fP points to the filter coefficients\&. 
.br
\fIpState\fP points to the state buffer\&. 
.RE
.PP

.SS "void arm_biquad_cascade_df2T_init_f64 (\fBarm_biquad_cascade_df2T_instance_f64\fP * S, uint8_t numStages, \fBfloat64_t\fP * pCoeffs, \fBfloat64_t\fP * pState)"

.PP
Initialization function for the floating-point transposed direct form II Biquad cascade filter\&. 
.PP
\fBParameters:\fP
.RS 4
\fIS\fP points to an instance of the filter data structure\&. 
.br
\fInumStages\fP number of 2nd order stages in the filter\&. 
.br
\fIpCoeffs\fP points to the filter coefficients\&. 
.br
\fIpState\fP points to the state buffer\&. 
.RE
.PP

.SS "void arm_biquad_cascade_stereo_df2T_f32 (const \fBarm_biquad_cascade_stereo_df2T_instance_f32\fP * S, \fBfloat32_t\fP * pSrc, \fBfloat32_t\fP * pDst, uint32_t blockSize)"

.PP
Processing function for the floating-point transposed direct form II Biquad cascade filter\&. 2 channels\&. 
.PP
\fBParameters:\fP
.RS 4
\fIS\fP points to an instance of the filter data structure\&. 
.br
\fIpSrc\fP points to the block of input data\&. 
.br
\fIpDst\fP points to the block of output data 
.br
\fIblockSize\fP number of samples to process\&. 
.RE
.PP

.SS "void arm_biquad_cascade_stereo_df2T_init_f32 (\fBarm_biquad_cascade_stereo_df2T_instance_f32\fP * S, uint8_t numStages, \fBfloat32_t\fP * pCoeffs, \fBfloat32_t\fP * pState)"

.PP
Initialization function for the floating-point transposed direct form II Biquad cascade filter\&. 
.PP
\fBParameters:\fP
.RS 4
\fIS\fP points to an instance of the filter data structure\&. 
.br
\fInumStages\fP number of 2nd order stages in the filter\&. 
.br
\fIpCoeffs\fP points to the filter coefficients\&. 
.br
\fIpState\fP points to the state buffer\&. 
.RE
.PP

.SS "void arm_cfft_f32 (const \fBarm_cfft_instance_f32\fP * S, \fBfloat32_t\fP * p1, uint8_t ifftFlag, uint8_t bitReverseFlag)"

.SS "void arm_cfft_q15 (const \fBarm_cfft_instance_q15\fP * S, \fBq15_t\fP * p1, uint8_t ifftFlag, uint8_t bitReverseFlag)"

.SS "void arm_cfft_q31 (const \fBarm_cfft_instance_q31\fP * S, \fBq31_t\fP * p1, uint8_t ifftFlag, uint8_t bitReverseFlag)"

.SS "void arm_cfft_radix2_f32 (const \fBarm_cfft_radix2_instance_f32\fP * S, \fBfloat32_t\fP * pSrc)"

.SS "\fBarm_status\fP arm_cfft_radix2_init_f32 (\fBarm_cfft_radix2_instance_f32\fP * S, uint16_t fftLen, uint8_t ifftFlag, uint8_t bitReverseFlag)"

.SS "\fBarm_status\fP arm_cfft_radix2_init_q15 (\fBarm_cfft_radix2_instance_q15\fP * S, uint16_t fftLen, uint8_t ifftFlag, uint8_t bitReverseFlag)"

.SS "\fBarm_status\fP arm_cfft_radix2_init_q31 (\fBarm_cfft_radix2_instance_q31\fP * S, uint16_t fftLen, uint8_t ifftFlag, uint8_t bitReverseFlag)"

.SS "void arm_cfft_radix2_q15 (const \fBarm_cfft_radix2_instance_q15\fP * S, \fBq15_t\fP * pSrc)"

.SS "void arm_cfft_radix2_q31 (const \fBarm_cfft_radix2_instance_q31\fP * S, \fBq31_t\fP * pSrc)"

.SS "void arm_cfft_radix4_f32 (const \fBarm_cfft_radix4_instance_f32\fP * S, \fBfloat32_t\fP * pSrc)"

.SS "\fBarm_status\fP arm_cfft_radix4_init_f32 (\fBarm_cfft_radix4_instance_f32\fP * S, uint16_t fftLen, uint8_t ifftFlag, uint8_t bitReverseFlag)"

.SS "\fBarm_status\fP arm_cfft_radix4_init_q15 (\fBarm_cfft_radix4_instance_q15\fP * S, uint16_t fftLen, uint8_t ifftFlag, uint8_t bitReverseFlag)"

.SS "\fBarm_status\fP arm_cfft_radix4_init_q31 (\fBarm_cfft_radix4_instance_q31\fP * S, uint16_t fftLen, uint8_t ifftFlag, uint8_t bitReverseFlag)"

.SS "void arm_cfft_radix4_q15 (const \fBarm_cfft_radix4_instance_q15\fP * S, \fBq15_t\fP * pSrc)"

.SS "void arm_cfft_radix4_q31 (const \fBarm_cfft_radix4_instance_q31\fP * S, \fBq31_t\fP * pSrc)"

.SS "void arm_cmplx_conj_f32 (\fBfloat32_t\fP * pSrc, \fBfloat32_t\fP * pDst, uint32_t numSamples)"

.PP
Floating-point complex conjugate\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrc\fP points to the input vector 
.br
\fIpDst\fP points to the output vector 
.br
\fInumSamples\fP number of complex samples in each vector 
.RE
.PP

.SS "void arm_cmplx_conj_q15 (\fBq15_t\fP * pSrc, \fBq15_t\fP * pDst, uint32_t numSamples)"

.PP
Q15 complex conjugate\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrc\fP points to the input vector 
.br
\fIpDst\fP points to the output vector 
.br
\fInumSamples\fP number of complex samples in each vector 
.RE
.PP

.SS "void arm_cmplx_conj_q31 (\fBq31_t\fP * pSrc, \fBq31_t\fP * pDst, uint32_t numSamples)"

.PP
Q31 complex conjugate\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrc\fP points to the input vector 
.br
\fIpDst\fP points to the output vector 
.br
\fInumSamples\fP number of complex samples in each vector 
.RE
.PP

.SS "void arm_cmplx_dot_prod_f32 (\fBfloat32_t\fP * pSrcA, \fBfloat32_t\fP * pSrcB, uint32_t numSamples, \fBfloat32_t\fP * realResult, \fBfloat32_t\fP * imagResult)"

.PP
Floating-point complex dot product\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrcA\fP points to the first input vector 
.br
\fIpSrcB\fP points to the second input vector 
.br
\fInumSamples\fP number of complex samples in each vector 
.br
\fIrealResult\fP real part of the result returned here 
.br
\fIimagResult\fP imaginary part of the result returned here 
.RE
.PP

.SS "void arm_cmplx_dot_prod_q15 (\fBq15_t\fP * pSrcA, \fBq15_t\fP * pSrcB, uint32_t numSamples, \fBq31_t\fP * realResult, \fBq31_t\fP * imagResult)"

.PP
Q15 complex dot product\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrcA\fP points to the first input vector 
.br
\fIpSrcB\fP points to the second input vector 
.br
\fInumSamples\fP number of complex samples in each vector 
.br
\fIrealResult\fP real part of the result returned here 
.br
\fIimagResult\fP imaginary part of the result returned here 
.RE
.PP

.SS "void arm_cmplx_dot_prod_q31 (\fBq31_t\fP * pSrcA, \fBq31_t\fP * pSrcB, uint32_t numSamples, \fBq63_t\fP * realResult, \fBq63_t\fP * imagResult)"

.PP
Q31 complex dot product\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrcA\fP points to the first input vector 
.br
\fIpSrcB\fP points to the second input vector 
.br
\fInumSamples\fP number of complex samples in each vector 
.br
\fIrealResult\fP real part of the result returned here 
.br
\fIimagResult\fP imaginary part of the result returned here 
.RE
.PP

.SS "void arm_cmplx_mag_f32 (\fBfloat32_t\fP * pSrc, \fBfloat32_t\fP * pDst, uint32_t numSamples)"

.PP
Floating-point complex magnitude\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrc\fP points to the complex input vector 
.br
\fIpDst\fP points to the real output vector 
.br
\fInumSamples\fP number of complex samples in the input vector 
.RE
.PP

.SS "void arm_cmplx_mag_q15 (\fBq15_t\fP * pSrc, \fBq15_t\fP * pDst, uint32_t numSamples)"

.PP
Q15 complex magnitude\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrc\fP points to the complex input vector 
.br
\fIpDst\fP points to the real output vector 
.br
\fInumSamples\fP number of complex samples in the input vector 
.RE
.PP

.SS "void arm_cmplx_mag_q31 (\fBq31_t\fP * pSrc, \fBq31_t\fP * pDst, uint32_t numSamples)"

.PP
Q31 complex magnitude\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrc\fP points to the complex input vector 
.br
\fIpDst\fP points to the real output vector 
.br
\fInumSamples\fP number of complex samples in the input vector 
.RE
.PP

.SS "void arm_cmplx_mag_squared_f32 (\fBfloat32_t\fP * pSrc, \fBfloat32_t\fP * pDst, uint32_t numSamples)"

.PP
Floating-point complex magnitude squared\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrc\fP points to the complex input vector 
.br
\fIpDst\fP points to the real output vector 
.br
\fInumSamples\fP number of complex samples in the input vector 
.RE
.PP

.SS "void arm_cmplx_mag_squared_q15 (\fBq15_t\fP * pSrc, \fBq15_t\fP * pDst, uint32_t numSamples)"

.PP
Q15 complex magnitude squared\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrc\fP points to the complex input vector 
.br
\fIpDst\fP points to the real output vector 
.br
\fInumSamples\fP number of complex samples in the input vector 
.RE
.PP

.SS "void arm_cmplx_mag_squared_q31 (\fBq31_t\fP * pSrc, \fBq31_t\fP * pDst, uint32_t numSamples)"

.PP
Q31 complex magnitude squared\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrc\fP points to the complex input vector 
.br
\fIpDst\fP points to the real output vector 
.br
\fInumSamples\fP number of complex samples in the input vector 
.RE
.PP

.SS "void arm_cmplx_mult_cmplx_f32 (\fBfloat32_t\fP * pSrcA, \fBfloat32_t\fP * pSrcB, \fBfloat32_t\fP * pDst, uint32_t numSamples)"

.PP
Floating-point complex-by-complex multiplication\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrcA\fP points to the first input vector 
.br
\fIpSrcB\fP points to the second input vector 
.br
\fIpDst\fP points to the output vector 
.br
\fInumSamples\fP number of complex samples in each vector 
.RE
.PP

.SS "void arm_cmplx_mult_cmplx_q15 (\fBq15_t\fP * pSrcA, \fBq15_t\fP * pSrcB, \fBq15_t\fP * pDst, uint32_t numSamples)"

.PP
Q15 complex-by-complex multiplication\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrcA\fP points to the first input vector 
.br
\fIpSrcB\fP points to the second input vector 
.br
\fIpDst\fP points to the output vector 
.br
\fInumSamples\fP number of complex samples in each vector 
.RE
.PP

.SS "void arm_cmplx_mult_cmplx_q31 (\fBq31_t\fP * pSrcA, \fBq31_t\fP * pSrcB, \fBq31_t\fP * pDst, uint32_t numSamples)"

.PP
Q31 complex-by-complex multiplication\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrcA\fP points to the first input vector 
.br
\fIpSrcB\fP points to the second input vector 
.br
\fIpDst\fP points to the output vector 
.br
\fInumSamples\fP number of complex samples in each vector 
.RE
.PP

.SS "void arm_cmplx_mult_real_f32 (\fBfloat32_t\fP * pSrcCmplx, \fBfloat32_t\fP * pSrcReal, \fBfloat32_t\fP * pCmplxDst, uint32_t numSamples)"

.PP
Floating-point complex-by-real multiplication\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrcCmplx\fP points to the complex input vector 
.br
\fIpSrcReal\fP points to the real input vector 
.br
\fIpCmplxDst\fP points to the complex output vector 
.br
\fInumSamples\fP number of samples in each vector 
.RE
.PP

.SS "void arm_cmplx_mult_real_q15 (\fBq15_t\fP * pSrcCmplx, \fBq15_t\fP * pSrcReal, \fBq15_t\fP * pCmplxDst, uint32_t numSamples)"

.PP
Q15 complex-by-real multiplication\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrcCmplx\fP points to the complex input vector 
.br
\fIpSrcReal\fP points to the real input vector 
.br
\fIpCmplxDst\fP points to the complex output vector 
.br
\fInumSamples\fP number of samples in each vector 
.RE
.PP

.SS "void arm_cmplx_mult_real_q31 (\fBq31_t\fP * pSrcCmplx, \fBq31_t\fP * pSrcReal, \fBq31_t\fP * pCmplxDst, uint32_t numSamples)"

.PP
Q31 complex-by-real multiplication\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrcCmplx\fP points to the complex input vector 
.br
\fIpSrcReal\fP points to the real input vector 
.br
\fIpCmplxDst\fP points to the complex output vector 
.br
\fInumSamples\fP number of samples in each vector 
.RE
.PP

.SS "void arm_conv_f32 (\fBfloat32_t\fP * pSrcA, uint32_t srcALen, \fBfloat32_t\fP * pSrcB, uint32_t srcBLen, \fBfloat32_t\fP * pDst)"

.PP
Convolution of floating-point sequences\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrcA\fP points to the first input sequence\&. 
.br
\fIsrcALen\fP length of the first input sequence\&. 
.br
\fIpSrcB\fP points to the second input sequence\&. 
.br
\fIsrcBLen\fP length of the second input sequence\&. 
.br
\fIpDst\fP points to the location where the output result is written\&. Length srcALen+srcBLen-1\&. 
.RE
.PP

.SS "void arm_conv_fast_opt_q15 (\fBq15_t\fP * pSrcA, uint32_t srcALen, \fBq15_t\fP * pSrcB, uint32_t srcBLen, \fBq15_t\fP * pDst, \fBq15_t\fP * pScratch1, \fBq15_t\fP * pScratch2)"

.PP
Convolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrcA\fP points to the first input sequence\&. 
.br
\fIsrcALen\fP length of the first input sequence\&. 
.br
\fIpSrcB\fP points to the second input sequence\&. 
.br
\fIsrcBLen\fP length of the second input sequence\&. 
.br
\fIpDst\fP points to the block of output data Length srcALen+srcBLen-1\&. 
.br
\fIpScratch1\fP points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2\&. 
.br
\fIpScratch2\fP points to scratch buffer of size min(srcALen, srcBLen)\&. 
.RE
.PP

.SS "void arm_conv_fast_q15 (\fBq15_t\fP * pSrcA, uint32_t srcALen, \fBq15_t\fP * pSrcB, uint32_t srcBLen, \fBq15_t\fP * pDst)"

.PP
Convolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrcA\fP points to the first input sequence\&. 
.br
\fIsrcALen\fP length of the first input sequence\&. 
.br
\fIpSrcB\fP points to the second input sequence\&. 
.br
\fIsrcBLen\fP length of the second input sequence\&. 
.br
\fIpDst\fP points to the block of output data Length srcALen+srcBLen-1\&. 
.RE
.PP

.SS "void arm_conv_fast_q31 (\fBq31_t\fP * pSrcA, uint32_t srcALen, \fBq31_t\fP * pSrcB, uint32_t srcBLen, \fBq31_t\fP * pDst)"

.PP
Convolution of Q31 sequences (fast version) for Cortex-M3 and Cortex-M4\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrcA\fP points to the first input sequence\&. 
.br
\fIsrcALen\fP length of the first input sequence\&. 
.br
\fIpSrcB\fP points to the second input sequence\&. 
.br
\fIsrcBLen\fP length of the second input sequence\&. 
.br
\fIpDst\fP points to the block of output data Length srcALen+srcBLen-1\&. 
.RE
.PP

.SS "void arm_conv_opt_q15 (\fBq15_t\fP * pSrcA, uint32_t srcALen, \fBq15_t\fP * pSrcB, uint32_t srcBLen, \fBq15_t\fP * pDst, \fBq15_t\fP * pScratch1, \fBq15_t\fP * pScratch2)"

.PP
Convolution of Q15 sequences\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrcA\fP points to the first input sequence\&. 
.br
\fIsrcALen\fP length of the first input sequence\&. 
.br
\fIpSrcB\fP points to the second input sequence\&. 
.br
\fIsrcBLen\fP length of the second input sequence\&. 
.br
\fIpDst\fP points to the block of output data Length srcALen+srcBLen-1\&. 
.br
\fIpScratch1\fP points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2\&. 
.br
\fIpScratch2\fP points to scratch buffer of size min(srcALen, srcBLen)\&. 
.RE
.PP

.SS "void arm_conv_opt_q7 (\fBq7_t\fP * pSrcA, uint32_t srcALen, \fBq7_t\fP * pSrcB, uint32_t srcBLen, \fBq7_t\fP * pDst, \fBq15_t\fP * pScratch1, \fBq15_t\fP * pScratch2)"

.PP
Convolution of Q7 sequences\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrcA\fP points to the first input sequence\&. 
.br
\fIsrcALen\fP length of the first input sequence\&. 
.br
\fIpSrcB\fP points to the second input sequence\&. 
.br
\fIsrcBLen\fP length of the second input sequence\&. 
.br
\fIpDst\fP points to the block of output data Length srcALen+srcBLen-1\&. 
.br
\fIpScratch1\fP points to scratch buffer(of type q15_t) of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2\&. 
.br
\fIpScratch2\fP points to scratch buffer (of type q15_t) of size min(srcALen, srcBLen)\&. 
.RE
.PP

.SS "\fBarm_status\fP arm_conv_partial_f32 (\fBfloat32_t\fP * pSrcA, uint32_t srcALen, \fBfloat32_t\fP * pSrcB, uint32_t srcBLen, \fBfloat32_t\fP * pDst, uint32_t firstIndex, uint32_t numPoints)"

.PP
Partial convolution of floating-point sequences\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrcA\fP points to the first input sequence\&. 
.br
\fIsrcALen\fP length of the first input sequence\&. 
.br
\fIpSrcB\fP points to the second input sequence\&. 
.br
\fIsrcBLen\fP length of the second input sequence\&. 
.br
\fIpDst\fP points to the block of output data 
.br
\fIfirstIndex\fP is the first output sample to start with\&. 
.br
\fInumPoints\fP is the number of output points to be computed\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2]\&. 
.RE
.PP

.SS "\fBarm_status\fP arm_conv_partial_fast_opt_q15 (\fBq15_t\fP * pSrcA, uint32_t srcALen, \fBq15_t\fP * pSrcB, uint32_t srcBLen, \fBq15_t\fP * pDst, uint32_t firstIndex, uint32_t numPoints, \fBq15_t\fP * pScratch1, \fBq15_t\fP * pScratch2)"

.PP
Partial convolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrcA\fP points to the first input sequence\&. 
.br
\fIsrcALen\fP length of the first input sequence\&. 
.br
\fIpSrcB\fP points to the second input sequence\&. 
.br
\fIsrcBLen\fP length of the second input sequence\&. 
.br
\fIpDst\fP points to the block of output data 
.br
\fIfirstIndex\fP is the first output sample to start with\&. 
.br
\fInumPoints\fP is the number of output points to be computed\&. 
.br
\fIpScratch1\fP points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2\&. 
.br
\fIpScratch2\fP points to scratch buffer of size min(srcALen, srcBLen)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2]\&. 
.RE
.PP

.SS "\fBarm_status\fP arm_conv_partial_fast_q15 (\fBq15_t\fP * pSrcA, uint32_t srcALen, \fBq15_t\fP * pSrcB, uint32_t srcBLen, \fBq15_t\fP * pDst, uint32_t firstIndex, uint32_t numPoints)"

.PP
Partial convolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrcA\fP points to the first input sequence\&. 
.br
\fIsrcALen\fP length of the first input sequence\&. 
.br
\fIpSrcB\fP points to the second input sequence\&. 
.br
\fIsrcBLen\fP length of the second input sequence\&. 
.br
\fIpDst\fP points to the block of output data 
.br
\fIfirstIndex\fP is the first output sample to start with\&. 
.br
\fInumPoints\fP is the number of output points to be computed\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2]\&. 
.RE
.PP

.SS "\fBarm_status\fP arm_conv_partial_fast_q31 (\fBq31_t\fP * pSrcA, uint32_t srcALen, \fBq31_t\fP * pSrcB, uint32_t srcBLen, \fBq31_t\fP * pDst, uint32_t firstIndex, uint32_t numPoints)"

.PP
Partial convolution of Q31 sequences (fast version) for Cortex-M3 and Cortex-M4\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrcA\fP points to the first input sequence\&. 
.br
\fIsrcALen\fP length of the first input sequence\&. 
.br
\fIpSrcB\fP points to the second input sequence\&. 
.br
\fIsrcBLen\fP length of the second input sequence\&. 
.br
\fIpDst\fP points to the block of output data 
.br
\fIfirstIndex\fP is the first output sample to start with\&. 
.br
\fInumPoints\fP is the number of output points to be computed\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2]\&. 
.RE
.PP

.SS "\fBarm_status\fP arm_conv_partial_opt_q15 (\fBq15_t\fP * pSrcA, uint32_t srcALen, \fBq15_t\fP * pSrcB, uint32_t srcBLen, \fBq15_t\fP * pDst, uint32_t firstIndex, uint32_t numPoints, \fBq15_t\fP * pScratch1, \fBq15_t\fP * pScratch2)"

.PP
Partial convolution of Q15 sequences\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrcA\fP points to the first input sequence\&. 
.br
\fIsrcALen\fP length of the first input sequence\&. 
.br
\fIpSrcB\fP points to the second input sequence\&. 
.br
\fIsrcBLen\fP length of the second input sequence\&. 
.br
\fIpDst\fP points to the block of output data 
.br
\fIfirstIndex\fP is the first output sample to start with\&. 
.br
\fInumPoints\fP is the number of output points to be computed\&. 
.br
\fIpScratch1\fP points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2\&. 
.br
\fIpScratch2\fP points to scratch buffer of size min(srcALen, srcBLen)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2]\&. 
.RE
.PP

.SS "\fBarm_status\fP arm_conv_partial_opt_q7 (\fBq7_t\fP * pSrcA, uint32_t srcALen, \fBq7_t\fP * pSrcB, uint32_t srcBLen, \fBq7_t\fP * pDst, uint32_t firstIndex, uint32_t numPoints, \fBq15_t\fP * pScratch1, \fBq15_t\fP * pScratch2)"

.PP
Partial convolution of Q7 sequences\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrcA\fP points to the first input sequence\&. 
.br
\fIsrcALen\fP length of the first input sequence\&. 
.br
\fIpSrcB\fP points to the second input sequence\&. 
.br
\fIsrcBLen\fP length of the second input sequence\&. 
.br
\fIpDst\fP points to the block of output data 
.br
\fIfirstIndex\fP is the first output sample to start with\&. 
.br
\fInumPoints\fP is the number of output points to be computed\&. 
.br
\fIpScratch1\fP points to scratch buffer(of type q15_t) of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2\&. 
.br
\fIpScratch2\fP points to scratch buffer (of type q15_t) of size min(srcALen, srcBLen)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2]\&. 
.RE
.PP

.SS "\fBarm_status\fP arm_conv_partial_q15 (\fBq15_t\fP * pSrcA, uint32_t srcALen, \fBq15_t\fP * pSrcB, uint32_t srcBLen, \fBq15_t\fP * pDst, uint32_t firstIndex, uint32_t numPoints)"

.PP
Partial convolution of Q15 sequences\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrcA\fP points to the first input sequence\&. 
.br
\fIsrcALen\fP length of the first input sequence\&. 
.br
\fIpSrcB\fP points to the second input sequence\&. 
.br
\fIsrcBLen\fP length of the second input sequence\&. 
.br
\fIpDst\fP points to the block of output data 
.br
\fIfirstIndex\fP is the first output sample to start with\&. 
.br
\fInumPoints\fP is the number of output points to be computed\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2]\&. 
.RE
.PP

.SS "\fBarm_status\fP arm_conv_partial_q31 (\fBq31_t\fP * pSrcA, uint32_t srcALen, \fBq31_t\fP * pSrcB, uint32_t srcBLen, \fBq31_t\fP * pDst, uint32_t firstIndex, uint32_t numPoints)"

.PP
Partial convolution of Q31 sequences\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrcA\fP points to the first input sequence\&. 
.br
\fIsrcALen\fP length of the first input sequence\&. 
.br
\fIpSrcB\fP points to the second input sequence\&. 
.br
\fIsrcBLen\fP length of the second input sequence\&. 
.br
\fIpDst\fP points to the block of output data 
.br
\fIfirstIndex\fP is the first output sample to start with\&. 
.br
\fInumPoints\fP is the number of output points to be computed\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2]\&. 
.RE
.PP

.SS "\fBarm_status\fP arm_conv_partial_q7 (\fBq7_t\fP * pSrcA, uint32_t srcALen, \fBq7_t\fP * pSrcB, uint32_t srcBLen, \fBq7_t\fP * pDst, uint32_t firstIndex, uint32_t numPoints)"

.PP
Partial convolution of Q7 sequences\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrcA\fP points to the first input sequence\&. 
.br
\fIsrcALen\fP length of the first input sequence\&. 
.br
\fIpSrcB\fP points to the second input sequence\&. 
.br
\fIsrcBLen\fP length of the second input sequence\&. 
.br
\fIpDst\fP points to the block of output data 
.br
\fIfirstIndex\fP is the first output sample to start with\&. 
.br
\fInumPoints\fP is the number of output points to be computed\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2]\&. 
.RE
.PP

.SS "void arm_conv_q15 (\fBq15_t\fP * pSrcA, uint32_t srcALen, \fBq15_t\fP * pSrcB, uint32_t srcBLen, \fBq15_t\fP * pDst)"

.PP
Convolution of Q15 sequences\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrcA\fP points to the first input sequence\&. 
.br
\fIsrcALen\fP length of the first input sequence\&. 
.br
\fIpSrcB\fP points to the second input sequence\&. 
.br
\fIsrcBLen\fP length of the second input sequence\&. 
.br
\fIpDst\fP points to the location where the output result is written\&. Length srcALen+srcBLen-1\&. 
.RE
.PP

.SS "void arm_conv_q31 (\fBq31_t\fP * pSrcA, uint32_t srcALen, \fBq31_t\fP * pSrcB, uint32_t srcBLen, \fBq31_t\fP * pDst)"

.PP
Convolution of Q31 sequences\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrcA\fP points to the first input sequence\&. 
.br
\fIsrcALen\fP length of the first input sequence\&. 
.br
\fIpSrcB\fP points to the second input sequence\&. 
.br
\fIsrcBLen\fP length of the second input sequence\&. 
.br
\fIpDst\fP points to the block of output data Length srcALen+srcBLen-1\&. 
.RE
.PP

.SS "void arm_conv_q7 (\fBq7_t\fP * pSrcA, uint32_t srcALen, \fBq7_t\fP * pSrcB, uint32_t srcBLen, \fBq7_t\fP * pDst)"

.PP
Convolution of Q7 sequences\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrcA\fP points to the first input sequence\&. 
.br
\fIsrcALen\fP length of the first input sequence\&. 
.br
\fIpSrcB\fP points to the second input sequence\&. 
.br
\fIsrcBLen\fP length of the second input sequence\&. 
.br
\fIpDst\fP points to the block of output data Length srcALen+srcBLen-1\&. 
.RE
.PP

.SS "void arm_copy_f32 (\fBfloat32_t\fP * pSrc, \fBfloat32_t\fP * pDst, uint32_t blockSize)"

.PP
Copies the elements of a floating-point vector\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrc\fP input pointer 
.br
\fIpDst\fP output pointer 
.br
\fIblockSize\fP number of samples to process 
.RE
.PP

.SS "void arm_copy_q15 (\fBq15_t\fP * pSrc, \fBq15_t\fP * pDst, uint32_t blockSize)"

.PP
Copies the elements of a Q15 vector\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrc\fP input pointer 
.br
\fIpDst\fP output pointer 
.br
\fIblockSize\fP number of samples to process 
.RE
.PP

.SS "void arm_copy_q31 (\fBq31_t\fP * pSrc, \fBq31_t\fP * pDst, uint32_t blockSize)"

.PP
Copies the elements of a Q31 vector\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrc\fP input pointer 
.br
\fIpDst\fP output pointer 
.br
\fIblockSize\fP number of samples to process 
.RE
.PP

.SS "void arm_copy_q7 (\fBq7_t\fP * pSrc, \fBq7_t\fP * pDst, uint32_t blockSize)"

.PP
Copies the elements of a Q7 vector\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrc\fP input pointer 
.br
\fIpDst\fP output pointer 
.br
\fIblockSize\fP number of samples to process 
.RE
.PP

.SS "void arm_correlate_f32 (\fBfloat32_t\fP * pSrcA, uint32_t srcALen, \fBfloat32_t\fP * pSrcB, uint32_t srcBLen, \fBfloat32_t\fP * pDst)"

.PP
Correlation of floating-point sequences\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrcA\fP points to the first input sequence\&. 
.br
\fIsrcALen\fP length of the first input sequence\&. 
.br
\fIpSrcB\fP points to the second input sequence\&. 
.br
\fIsrcBLen\fP length of the second input sequence\&. 
.br
\fIpDst\fP points to the block of output data Length 2 * max(srcALen, srcBLen) - 1\&. 
.RE
.PP

.SS "void arm_correlate_fast_opt_q15 (\fBq15_t\fP * pSrcA, uint32_t srcALen, \fBq15_t\fP * pSrcB, uint32_t srcBLen, \fBq15_t\fP * pDst, \fBq15_t\fP * pScratch)"

.PP
Correlation of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrcA\fP points to the first input sequence\&. 
.br
\fIsrcALen\fP length of the first input sequence\&. 
.br
\fIpSrcB\fP points to the second input sequence\&. 
.br
\fIsrcBLen\fP length of the second input sequence\&. 
.br
\fIpDst\fP points to the block of output data Length 2 * max(srcALen, srcBLen) - 1\&. 
.br
\fIpScratch\fP points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2\&. 
.RE
.PP

.SS "void arm_correlate_fast_q15 (\fBq15_t\fP * pSrcA, uint32_t srcALen, \fBq15_t\fP * pSrcB, uint32_t srcBLen, \fBq15_t\fP * pDst)"

.PP
Correlation of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrcA\fP points to the first input sequence\&. 
.br
\fIsrcALen\fP length of the first input sequence\&. 
.br
\fIpSrcB\fP points to the second input sequence\&. 
.br
\fIsrcBLen\fP length of the second input sequence\&. 
.br
\fIpDst\fP points to the block of output data Length 2 * max(srcALen, srcBLen) - 1\&. 
.RE
.PP

.SS "void arm_correlate_fast_q31 (\fBq31_t\fP * pSrcA, uint32_t srcALen, \fBq31_t\fP * pSrcB, uint32_t srcBLen, \fBq31_t\fP * pDst)"

.PP
Correlation of Q31 sequences (fast version) for Cortex-M3 and Cortex-M4\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrcA\fP points to the first input sequence\&. 
.br
\fIsrcALen\fP length of the first input sequence\&. 
.br
\fIpSrcB\fP points to the second input sequence\&. 
.br
\fIsrcBLen\fP length of the second input sequence\&. 
.br
\fIpDst\fP points to the block of output data Length 2 * max(srcALen, srcBLen) - 1\&. 
.RE
.PP

.SS "void arm_correlate_opt_q15 (\fBq15_t\fP * pSrcA, uint32_t srcALen, \fBq15_t\fP * pSrcB, uint32_t srcBLen, \fBq15_t\fP * pDst, \fBq15_t\fP * pScratch)"

.PP
Correlation of Q15 sequences\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrcA\fP points to the first input sequence\&. 
.br
\fIsrcALen\fP length of the first input sequence\&. 
.br
\fIpSrcB\fP points to the second input sequence\&. 
.br
\fIsrcBLen\fP length of the second input sequence\&. 
.br
\fIpDst\fP points to the block of output data Length 2 * max(srcALen, srcBLen) - 1\&. 
.br
\fIpScratch\fP points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2\&. 
.RE
.PP

.SS "void arm_correlate_opt_q7 (\fBq7_t\fP * pSrcA, uint32_t srcALen, \fBq7_t\fP * pSrcB, uint32_t srcBLen, \fBq7_t\fP * pDst, \fBq15_t\fP * pScratch1, \fBq15_t\fP * pScratch2)"

.PP
Correlation of Q7 sequences\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrcA\fP points to the first input sequence\&. 
.br
\fIsrcALen\fP length of the first input sequence\&. 
.br
\fIpSrcB\fP points to the second input sequence\&. 
.br
\fIsrcBLen\fP length of the second input sequence\&. 
.br
\fIpDst\fP points to the block of output data Length 2 * max(srcALen, srcBLen) - 1\&. 
.br
\fIpScratch1\fP points to scratch buffer(of type q15_t) of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2\&. 
.br
\fIpScratch2\fP points to scratch buffer (of type q15_t) of size min(srcALen, srcBLen)\&. 
.RE
.PP

.SS "void arm_correlate_q15 (\fBq15_t\fP * pSrcA, uint32_t srcALen, \fBq15_t\fP * pSrcB, uint32_t srcBLen, \fBq15_t\fP * pDst)"

.PP
Correlation of Q15 sequences\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrcA\fP points to the first input sequence\&. 
.br
\fIsrcALen\fP length of the first input sequence\&. 
.br
\fIpSrcB\fP points to the second input sequence\&. 
.br
\fIsrcBLen\fP length of the second input sequence\&. 
.br
\fIpDst\fP points to the block of output data Length 2 * max(srcALen, srcBLen) - 1\&. 
.RE
.PP

.SS "void arm_correlate_q31 (\fBq31_t\fP * pSrcA, uint32_t srcALen, \fBq31_t\fP * pSrcB, uint32_t srcBLen, \fBq31_t\fP * pDst)"

.PP
Correlation of Q31 sequences\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrcA\fP points to the first input sequence\&. 
.br
\fIsrcALen\fP length of the first input sequence\&. 
.br
\fIpSrcB\fP points to the second input sequence\&. 
.br
\fIsrcBLen\fP length of the second input sequence\&. 
.br
\fIpDst\fP points to the block of output data Length 2 * max(srcALen, srcBLen) - 1\&. 
.RE
.PP

.SS "void arm_correlate_q7 (\fBq7_t\fP * pSrcA, uint32_t srcALen, \fBq7_t\fP * pSrcB, uint32_t srcBLen, \fBq7_t\fP * pDst)"

.PP
Correlation of Q7 sequences\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrcA\fP points to the first input sequence\&. 
.br
\fIsrcALen\fP length of the first input sequence\&. 
.br
\fIpSrcB\fP points to the second input sequence\&. 
.br
\fIsrcBLen\fP length of the second input sequence\&. 
.br
\fIpDst\fP points to the block of output data Length 2 * max(srcALen, srcBLen) - 1\&. 
.RE
.PP

.SS "\fBfloat32_t\fP arm_cos_f32 (\fBfloat32_t\fP x)"

.PP
Fast approximation to the trigonometric cosine function for floating-point data\&. 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP input value in radians\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
cos(x)\&. 
.RE
.PP

.SS "\fBq15_t\fP arm_cos_q15 (\fBq15_t\fP x)"

.PP
Fast approximation to the trigonometric cosine function for Q15 data\&. 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP Scaled input value in radians\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
cos(x)\&. 
.RE
.PP

.SS "\fBq31_t\fP arm_cos_q31 (\fBq31_t\fP x)"

.PP
Fast approximation to the trigonometric cosine function for Q31 data\&. 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP Scaled input value in radians\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
cos(x)\&. 
.RE
.PP

.SS "void arm_dct4_f32 (const \fBarm_dct4_instance_f32\fP * S, \fBfloat32_t\fP * pState, \fBfloat32_t\fP * pInlineBuffer)"

.PP
Processing function for the floating-point DCT4/IDCT4\&. 
.PP
\fBParameters:\fP
.RS 4
\fIS\fP points to an instance of the floating-point DCT4/IDCT4 structure\&. 
.br
\fIpState\fP points to state buffer\&. 
.br
\fIpInlineBuffer\fP points to the in-place input and output buffer\&. 
.RE
.PP

.SS "\fBarm_status\fP arm_dct4_init_f32 (\fBarm_dct4_instance_f32\fP * S, \fBarm_rfft_instance_f32\fP * S_RFFT, \fBarm_cfft_radix4_instance_f32\fP * S_CFFT, uint16_t N, uint16_t Nby2, \fBfloat32_t\fP normalize)"

.PP
Initialization function for the floating-point DCT4/IDCT4\&. 
.PP
\fBParameters:\fP
.RS 4
\fIS\fP points to an instance of floating-point DCT4/IDCT4 structure\&. 
.br
\fIS_RFFT\fP points to an instance of floating-point RFFT/RIFFT structure\&. 
.br
\fIS_CFFT\fP points to an instance of floating-point CFFT/CIFFT structure\&. 
.br
\fIN\fP length of the DCT4\&. 
.br
\fINby2\fP half of the length of the DCT4\&. 
.br
\fInormalize\fP normalizing factor\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
arm_status function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_ARGUMENT_ERROR if \fCfftLenReal\fP is not a supported transform length\&. 
.RE
.PP

.SS "\fBarm_status\fP arm_dct4_init_q15 (\fBarm_dct4_instance_q15\fP * S, \fBarm_rfft_instance_q15\fP * S_RFFT, \fBarm_cfft_radix4_instance_q15\fP * S_CFFT, uint16_t N, uint16_t Nby2, \fBq15_t\fP normalize)"

.PP
Initialization function for the Q15 DCT4/IDCT4\&. 
.PP
\fBParameters:\fP
.RS 4
\fIS\fP points to an instance of Q15 DCT4/IDCT4 structure\&. 
.br
\fIS_RFFT\fP points to an instance of Q15 RFFT/RIFFT structure\&. 
.br
\fIS_CFFT\fP points to an instance of Q15 CFFT/CIFFT structure\&. 
.br
\fIN\fP length of the DCT4\&. 
.br
\fINby2\fP half of the length of the DCT4\&. 
.br
\fInormalize\fP normalizing factor\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
arm_status function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_ARGUMENT_ERROR if \fCN\fP is not a supported transform length\&. 
.RE
.PP

.SS "\fBarm_status\fP arm_dct4_init_q31 (\fBarm_dct4_instance_q31\fP * S, \fBarm_rfft_instance_q31\fP * S_RFFT, \fBarm_cfft_radix4_instance_q31\fP * S_CFFT, uint16_t N, uint16_t Nby2, \fBq31_t\fP normalize)"

.PP
Initialization function for the Q31 DCT4/IDCT4\&. 
.PP
\fBParameters:\fP
.RS 4
\fIS\fP points to an instance of Q31 DCT4/IDCT4 structure\&. 
.br
\fIS_RFFT\fP points to an instance of Q31 RFFT/RIFFT structure 
.br
\fIS_CFFT\fP points to an instance of Q31 CFFT/CIFFT structure 
.br
\fIN\fP length of the DCT4\&. 
.br
\fINby2\fP half of the length of the DCT4\&. 
.br
\fInormalize\fP normalizing factor\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
arm_status function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_ARGUMENT_ERROR if \fCN\fP is not a supported transform length\&. 
.RE
.PP

.SS "void arm_dct4_q15 (const \fBarm_dct4_instance_q15\fP * S, \fBq15_t\fP * pState, \fBq15_t\fP * pInlineBuffer)"

.PP
Processing function for the Q15 DCT4/IDCT4\&. 
.PP
\fBParameters:\fP
.RS 4
\fIS\fP points to an instance of the Q15 DCT4 structure\&. 
.br
\fIpState\fP points to state buffer\&. 
.br
\fIpInlineBuffer\fP points to the in-place input and output buffer\&. 
.RE
.PP

.SS "void arm_dct4_q31 (const \fBarm_dct4_instance_q31\fP * S, \fBq31_t\fP * pState, \fBq31_t\fP * pInlineBuffer)"

.PP
Processing function for the Q31 DCT4/IDCT4\&. 
.PP
\fBParameters:\fP
.RS 4
\fIS\fP points to an instance of the Q31 DCT4 structure\&. 
.br
\fIpState\fP points to state buffer\&. 
.br
\fIpInlineBuffer\fP points to the in-place input and output buffer\&. 
.RE
.PP

.SS "void arm_dot_prod_f32 (\fBfloat32_t\fP * pSrcA, \fBfloat32_t\fP * pSrcB, uint32_t blockSize, \fBfloat32_t\fP * result)"

.PP
Dot product of floating-point vectors\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrcA\fP points to the first input vector 
.br
\fIpSrcB\fP points to the second input vector 
.br
\fIblockSize\fP number of samples in each vector 
.br
\fIresult\fP output result returned here 
.RE
.PP

.SS "void arm_dot_prod_q15 (\fBq15_t\fP * pSrcA, \fBq15_t\fP * pSrcB, uint32_t blockSize, \fBq63_t\fP * result)"

.PP
Dot product of Q15 vectors\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrcA\fP points to the first input vector 
.br
\fIpSrcB\fP points to the second input vector 
.br
\fIblockSize\fP number of samples in each vector 
.br
\fIresult\fP output result returned here 
.RE
.PP

.SS "void arm_dot_prod_q31 (\fBq31_t\fP * pSrcA, \fBq31_t\fP * pSrcB, uint32_t blockSize, \fBq63_t\fP * result)"

.PP
Dot product of Q31 vectors\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrcA\fP points to the first input vector 
.br
\fIpSrcB\fP points to the second input vector 
.br
\fIblockSize\fP number of samples in each vector 
.br
\fIresult\fP output result returned here 
.RE
.PP

.SS "void arm_dot_prod_q7 (\fBq7_t\fP * pSrcA, \fBq7_t\fP * pSrcB, uint32_t blockSize, \fBq31_t\fP * result)"

.PP
Dot product of Q7 vectors\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrcA\fP points to the first input vector 
.br
\fIpSrcB\fP points to the second input vector 
.br
\fIblockSize\fP number of samples in each vector 
.br
\fIresult\fP output result returned here 
.RE
.PP

.SS "void arm_fill_f32 (\fBfloat32_t\fP value, \fBfloat32_t\fP * pDst, uint32_t blockSize)"

.PP
Fills a constant value into a floating-point vector\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvalue\fP input value to be filled 
.br
\fIpDst\fP output pointer 
.br
\fIblockSize\fP number of samples to process 
.RE
.PP

.SS "void arm_fill_q15 (\fBq15_t\fP value, \fBq15_t\fP * pDst, uint32_t blockSize)"

.PP
Fills a constant value into a Q15 vector\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvalue\fP input value to be filled 
.br
\fIpDst\fP output pointer 
.br
\fIblockSize\fP number of samples to process 
.RE
.PP

.SS "void arm_fill_q31 (\fBq31_t\fP value, \fBq31_t\fP * pDst, uint32_t blockSize)"

.PP
Fills a constant value into a Q31 vector\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvalue\fP input value to be filled 
.br
\fIpDst\fP output pointer 
.br
\fIblockSize\fP number of samples to process 
.RE
.PP

.SS "void arm_fill_q7 (\fBq7_t\fP value, \fBq7_t\fP * pDst, uint32_t blockSize)"

.PP
Fills a constant value into a Q7 vector\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvalue\fP input value to be filled 
.br
\fIpDst\fP output pointer 
.br
\fIblockSize\fP number of samples to process 
.RE
.PP

.SS "void arm_fir_decimate_f32 (const \fBarm_fir_decimate_instance_f32\fP * S, \fBfloat32_t\fP * pSrc, \fBfloat32_t\fP * pDst, uint32_t blockSize)"

.PP
Processing function for the floating-point FIR decimator\&. 
.PP
\fBParameters:\fP
.RS 4
\fIS\fP points to an instance of the floating-point FIR decimator structure\&. 
.br
\fIpSrc\fP points to the block of input data\&. 
.br
\fIpDst\fP points to the block of output data 
.br
\fIblockSize\fP number of input samples to process per call\&. 
.RE
.PP

.SS "void arm_fir_decimate_fast_q15 (const \fBarm_fir_decimate_instance_q15\fP * S, \fBq15_t\fP * pSrc, \fBq15_t\fP * pDst, uint32_t blockSize)"

.PP
Processing function for the Q15 FIR decimator (fast variant) for Cortex-M3 and Cortex-M4\&. 
.PP
\fBParameters:\fP
.RS 4
\fIS\fP points to an instance of the Q15 FIR decimator structure\&. 
.br
\fIpSrc\fP points to the block of input data\&. 
.br
\fIpDst\fP points to the block of output data 
.br
\fIblockSize\fP number of input samples to process per call\&. 
.RE
.PP

.SS "void arm_fir_decimate_fast_q31 (\fBarm_fir_decimate_instance_q31\fP * S, \fBq31_t\fP * pSrc, \fBq31_t\fP * pDst, uint32_t blockSize)"

.PP
Processing function for the Q31 FIR decimator (fast variant) for Cortex-M3 and Cortex-M4\&. 
.PP
\fBParameters:\fP
.RS 4
\fIS\fP points to an instance of the Q31 FIR decimator structure\&. 
.br
\fIpSrc\fP points to the block of input data\&. 
.br
\fIpDst\fP points to the block of output data 
.br
\fIblockSize\fP number of input samples to process per call\&. 
.RE
.PP

.SS "\fBarm_status\fP arm_fir_decimate_init_f32 (\fBarm_fir_decimate_instance_f32\fP * S, uint16_t numTaps, uint8_t M, \fBfloat32_t\fP * pCoeffs, \fBfloat32_t\fP * pState, uint32_t blockSize)"

.PP
Initialization function for the floating-point FIR decimator\&. 
.PP
\fBParameters:\fP
.RS 4
\fIS\fP points to an instance of the floating-point FIR decimator structure\&. 
.br
\fInumTaps\fP number of coefficients in the filter\&. 
.br
\fIM\fP decimation factor\&. 
.br
\fIpCoeffs\fP points to the filter coefficients\&. 
.br
\fIpState\fP points to the state buffer\&. 
.br
\fIblockSize\fP number of input samples to process per call\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_LENGTH_ERROR if \fCblockSize\fP is not a multiple of \fCM\fP\&. 
.RE
.PP

.SS "\fBarm_status\fP arm_fir_decimate_init_q15 (\fBarm_fir_decimate_instance_q15\fP * S, uint16_t numTaps, uint8_t M, \fBq15_t\fP * pCoeffs, \fBq15_t\fP * pState, uint32_t blockSize)"

.PP
Initialization function for the Q15 FIR decimator\&. 
.PP
\fBParameters:\fP
.RS 4
\fIS\fP points to an instance of the Q15 FIR decimator structure\&. 
.br
\fInumTaps\fP number of coefficients in the filter\&. 
.br
\fIM\fP decimation factor\&. 
.br
\fIpCoeffs\fP points to the filter coefficients\&. 
.br
\fIpState\fP points to the state buffer\&. 
.br
\fIblockSize\fP number of input samples to process per call\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_LENGTH_ERROR if \fCblockSize\fP is not a multiple of \fCM\fP\&. 
.RE
.PP

.SS "\fBarm_status\fP arm_fir_decimate_init_q31 (\fBarm_fir_decimate_instance_q31\fP * S, uint16_t numTaps, uint8_t M, \fBq31_t\fP * pCoeffs, \fBq31_t\fP * pState, uint32_t blockSize)"

.PP
Initialization function for the Q31 FIR decimator\&. 
.PP
\fBParameters:\fP
.RS 4
\fIS\fP points to an instance of the Q31 FIR decimator structure\&. 
.br
\fInumTaps\fP number of coefficients in the filter\&. 
.br
\fIM\fP decimation factor\&. 
.br
\fIpCoeffs\fP points to the filter coefficients\&. 
.br
\fIpState\fP points to the state buffer\&. 
.br
\fIblockSize\fP number of input samples to process per call\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_LENGTH_ERROR if \fCblockSize\fP is not a multiple of \fCM\fP\&. 
.RE
.PP

.SS "void arm_fir_decimate_q15 (const \fBarm_fir_decimate_instance_q15\fP * S, \fBq15_t\fP * pSrc, \fBq15_t\fP * pDst, uint32_t blockSize)"

.PP
Processing function for the Q15 FIR decimator\&. 
.PP
\fBParameters:\fP
.RS 4
\fIS\fP points to an instance of the Q15 FIR decimator structure\&. 
.br
\fIpSrc\fP points to the block of input data\&. 
.br
\fIpDst\fP points to the block of output data 
.br
\fIblockSize\fP number of input samples to process per call\&. 
.RE
.PP

.SS "void arm_fir_decimate_q31 (const \fBarm_fir_decimate_instance_q31\fP * S, \fBq31_t\fP * pSrc, \fBq31_t\fP * pDst, uint32_t blockSize)"

.PP
Processing function for the Q31 FIR decimator\&. 
.PP
\fBParameters:\fP
.RS 4
\fIS\fP points to an instance of the Q31 FIR decimator structure\&. 
.br
\fIpSrc\fP points to the block of input data\&. 
.br
\fIpDst\fP points to the block of output data 
.br
\fIblockSize\fP number of input samples to process per call\&. 
.RE
.PP

.SS "void arm_fir_f32 (const \fBarm_fir_instance_f32\fP * S, \fBfloat32_t\fP * pSrc, \fBfloat32_t\fP * pDst, uint32_t blockSize)"

.PP
Processing function for the floating-point FIR filter\&. 
.PP
\fBParameters:\fP
.RS 4
\fIS\fP points to an instance of the floating-point FIR structure\&. 
.br
\fIpSrc\fP points to the block of input data\&. 
.br
\fIpDst\fP points to the block of output data\&. 
.br
\fIblockSize\fP number of samples to process\&. 
.RE
.PP

.SS "void arm_fir_fast_q15 (const \fBarm_fir_instance_q15\fP * S, \fBq15_t\fP * pSrc, \fBq15_t\fP * pDst, uint32_t blockSize)"

.PP
Processing function for the fast Q15 FIR filter for Cortex-M3 and Cortex-M4\&. 
.PP
\fBParameters:\fP
.RS 4
\fIS\fP points to an instance of the Q15 FIR filter structure\&. 
.br
\fIpSrc\fP points to the block of input data\&. 
.br
\fIpDst\fP points to the block of output data\&. 
.br
\fIblockSize\fP number of samples to process\&. 
.RE
.PP

.SS "void arm_fir_fast_q31 (const \fBarm_fir_instance_q31\fP * S, \fBq31_t\fP * pSrc, \fBq31_t\fP * pDst, uint32_t blockSize)"

.PP
Processing function for the fast Q31 FIR filter for Cortex-M3 and Cortex-M4\&. 
.PP
\fBParameters:\fP
.RS 4
\fIS\fP points to an instance of the Q31 FIR structure\&. 
.br
\fIpSrc\fP points to the block of input data\&. 
.br
\fIpDst\fP points to the block of output data\&. 
.br
\fIblockSize\fP number of samples to process\&. 
.RE
.PP

.SS "void arm_fir_init_f32 (\fBarm_fir_instance_f32\fP * S, uint16_t numTaps, \fBfloat32_t\fP * pCoeffs, \fBfloat32_t\fP * pState, uint32_t blockSize)"

.PP
Initialization function for the floating-point FIR filter\&. 
.PP
\fBParameters:\fP
.RS 4
\fIS\fP points to an instance of the floating-point FIR filter structure\&. 
.br
\fInumTaps\fP Number of filter coefficients in the filter\&. 
.br
\fIpCoeffs\fP points to the filter coefficients\&. 
.br
\fIpState\fP points to the state buffer\&. 
.br
\fIblockSize\fP number of samples that are processed at a time\&. 
.RE
.PP

.SS "\fBarm_status\fP arm_fir_init_q15 (\fBarm_fir_instance_q15\fP * S, uint16_t numTaps, \fBq15_t\fP * pCoeffs, \fBq15_t\fP * pState, uint32_t blockSize)"

.PP
Initialization function for the Q15 FIR filter\&. 
.PP
\fBParameters:\fP
.RS 4
\fIS\fP points to an instance of the Q15 FIR filter structure\&. 
.br
\fInumTaps\fP Number of filter coefficients in the filter\&. Must be even and greater than or equal to 4\&. 
.br
\fIpCoeffs\fP points to the filter coefficients\&. 
.br
\fIpState\fP points to the state buffer\&. 
.br
\fIblockSize\fP number of samples that are processed at a time\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
The function returns ARM_MATH_SUCCESS if initialization was successful or ARM_MATH_ARGUMENT_ERROR if \fCnumTaps\fP is not a supported value\&. 
.RE
.PP

.SS "void arm_fir_init_q31 (\fBarm_fir_instance_q31\fP * S, uint16_t numTaps, \fBq31_t\fP * pCoeffs, \fBq31_t\fP * pState, uint32_t blockSize)"

.PP
Initialization function for the Q31 FIR filter\&. 
.PP
\fBParameters:\fP
.RS 4
\fIS\fP points to an instance of the Q31 FIR structure\&. 
.br
\fInumTaps\fP Number of filter coefficients in the filter\&. 
.br
\fIpCoeffs\fP points to the filter coefficients\&. 
.br
\fIpState\fP points to the state buffer\&. 
.br
\fIblockSize\fP number of samples that are processed at a time\&. 
.RE
.PP

.SS "void arm_fir_init_q7 (\fBarm_fir_instance_q7\fP * S, uint16_t numTaps, \fBq7_t\fP * pCoeffs, \fBq7_t\fP * pState, uint32_t blockSize)"

.PP
Initialization function for the Q7 FIR filter\&. 
.PP
\fBParameters:\fP
.RS 4
\fIS\fP points to an instance of the Q7 FIR structure\&. 
.br
\fInumTaps\fP Number of filter coefficients in the filter\&. 
.br
\fIpCoeffs\fP points to the filter coefficients\&. 
.br
\fIpState\fP points to the state buffer\&. 
.br
\fIblockSize\fP number of samples that are processed\&. 
.RE
.PP

.SS "void arm_fir_interpolate_f32 (const \fBarm_fir_interpolate_instance_f32\fP * S, \fBfloat32_t\fP * pSrc, \fBfloat32_t\fP * pDst, uint32_t blockSize)"

.PP
Processing function for the floating-point FIR interpolator\&. 
.PP
\fBParameters:\fP
.RS 4
\fIS\fP points to an instance of the floating-point FIR interpolator structure\&. 
.br
\fIpSrc\fP points to the block of input data\&. 
.br
\fIpDst\fP points to the block of output data\&. 
.br
\fIblockSize\fP number of input samples to process per call\&. 
.RE
.PP

.SS "\fBarm_status\fP arm_fir_interpolate_init_f32 (\fBarm_fir_interpolate_instance_f32\fP * S, uint8_t L, uint16_t numTaps, \fBfloat32_t\fP * pCoeffs, \fBfloat32_t\fP * pState, uint32_t blockSize)"

.PP
Initialization function for the floating-point FIR interpolator\&. 
.PP
\fBParameters:\fP
.RS 4
\fIS\fP points to an instance of the floating-point FIR interpolator structure\&. 
.br
\fIL\fP upsample factor\&. 
.br
\fInumTaps\fP number of filter coefficients in the filter\&. 
.br
\fIpCoeffs\fP points to the filter coefficient buffer\&. 
.br
\fIpState\fP points to the state buffer\&. 
.br
\fIblockSize\fP number of input samples to process per call\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_LENGTH_ERROR if the filter length \fCnumTaps\fP is not a multiple of the interpolation factor \fCL\fP\&. 
.RE
.PP

.SS "\fBarm_status\fP arm_fir_interpolate_init_q15 (\fBarm_fir_interpolate_instance_q15\fP * S, uint8_t L, uint16_t numTaps, \fBq15_t\fP * pCoeffs, \fBq15_t\fP * pState, uint32_t blockSize)"

.PP
Initialization function for the Q15 FIR interpolator\&. 
.PP
\fBParameters:\fP
.RS 4
\fIS\fP points to an instance of the Q15 FIR interpolator structure\&. 
.br
\fIL\fP upsample factor\&. 
.br
\fInumTaps\fP number of filter coefficients in the filter\&. 
.br
\fIpCoeffs\fP points to the filter coefficient buffer\&. 
.br
\fIpState\fP points to the state buffer\&. 
.br
\fIblockSize\fP number of input samples to process per call\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_LENGTH_ERROR if the filter length \fCnumTaps\fP is not a multiple of the interpolation factor \fCL\fP\&. 
.RE
.PP

.SS "\fBarm_status\fP arm_fir_interpolate_init_q31 (\fBarm_fir_interpolate_instance_q31\fP * S, uint8_t L, uint16_t numTaps, \fBq31_t\fP * pCoeffs, \fBq31_t\fP * pState, uint32_t blockSize)"

.PP
Initialization function for the Q31 FIR interpolator\&. 
.PP
\fBParameters:\fP
.RS 4
\fIS\fP points to an instance of the Q31 FIR interpolator structure\&. 
.br
\fIL\fP upsample factor\&. 
.br
\fInumTaps\fP number of filter coefficients in the filter\&. 
.br
\fIpCoeffs\fP points to the filter coefficient buffer\&. 
.br
\fIpState\fP points to the state buffer\&. 
.br
\fIblockSize\fP number of input samples to process per call\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_LENGTH_ERROR if the filter length \fCnumTaps\fP is not a multiple of the interpolation factor \fCL\fP\&. 
.RE
.PP

.SS "void arm_fir_interpolate_q15 (const \fBarm_fir_interpolate_instance_q15\fP * S, \fBq15_t\fP * pSrc, \fBq15_t\fP * pDst, uint32_t blockSize)"

.PP
Processing function for the Q15 FIR interpolator\&. 
.PP
\fBParameters:\fP
.RS 4
\fIS\fP points to an instance of the Q15 FIR interpolator structure\&. 
.br
\fIpSrc\fP points to the block of input data\&. 
.br
\fIpDst\fP points to the block of output data\&. 
.br
\fIblockSize\fP number of input samples to process per call\&. 
.RE
.PP

.SS "void arm_fir_interpolate_q31 (const \fBarm_fir_interpolate_instance_q31\fP * S, \fBq31_t\fP * pSrc, \fBq31_t\fP * pDst, uint32_t blockSize)"

.PP
Processing function for the Q31 FIR interpolator\&. 
.PP
\fBParameters:\fP
.RS 4
\fIS\fP points to an instance of the Q15 FIR interpolator structure\&. 
.br
\fIpSrc\fP points to the block of input data\&. 
.br
\fIpDst\fP points to the block of output data\&. 
.br
\fIblockSize\fP number of input samples to process per call\&. 
.RE
.PP

.SS "void arm_fir_lattice_f32 (const \fBarm_fir_lattice_instance_f32\fP * S, \fBfloat32_t\fP * pSrc, \fBfloat32_t\fP * pDst, uint32_t blockSize)"

.PP
Processing function for the floating-point FIR lattice filter\&. 
.PP
\fBParameters:\fP
.RS 4
\fIS\fP points to an instance of the floating-point FIR lattice structure\&. 
.br
\fIpSrc\fP points to the block of input data\&. 
.br
\fIpDst\fP points to the block of output data 
.br
\fIblockSize\fP number of samples to process\&. 
.RE
.PP

.SS "void arm_fir_lattice_init_f32 (\fBarm_fir_lattice_instance_f32\fP * S, uint16_t numStages, \fBfloat32_t\fP * pCoeffs, \fBfloat32_t\fP * pState)"

.PP
Initialization function for the floating-point FIR lattice filter\&. 
.PP
\fBParameters:\fP
.RS 4
\fIS\fP points to an instance of the floating-point FIR lattice structure\&. 
.br
\fInumStages\fP number of filter stages\&. 
.br
\fIpCoeffs\fP points to the coefficient buffer\&. The array is of length numStages\&. 
.br
\fIpState\fP points to the state buffer\&. The array is of length numStages\&. 
.RE
.PP

.SS "void arm_fir_lattice_init_q15 (\fBarm_fir_lattice_instance_q15\fP * S, uint16_t numStages, \fBq15_t\fP * pCoeffs, \fBq15_t\fP * pState)"

.PP
Initialization function for the Q15 FIR lattice filter\&. 
.PP
\fBParameters:\fP
.RS 4
\fIS\fP points to an instance of the Q15 FIR lattice structure\&. 
.br
\fInumStages\fP number of filter stages\&. 
.br
\fIpCoeffs\fP points to the coefficient buffer\&. The array is of length numStages\&. 
.br
\fIpState\fP points to the state buffer\&. The array is of length numStages\&. 
.RE
.PP

.SS "void arm_fir_lattice_init_q31 (\fBarm_fir_lattice_instance_q31\fP * S, uint16_t numStages, \fBq31_t\fP * pCoeffs, \fBq31_t\fP * pState)"

.PP
Initialization function for the Q31 FIR lattice filter\&. 
.PP
\fBParameters:\fP
.RS 4
\fIS\fP points to an instance of the Q31 FIR lattice structure\&. 
.br
\fInumStages\fP number of filter stages\&. 
.br
\fIpCoeffs\fP points to the coefficient buffer\&. The array is of length numStages\&. 
.br
\fIpState\fP points to the state buffer\&. The array is of length numStages\&. 
.RE
.PP

.SS "void arm_fir_lattice_q15 (const \fBarm_fir_lattice_instance_q15\fP * S, \fBq15_t\fP * pSrc, \fBq15_t\fP * pDst, uint32_t blockSize)"

.PP
Processing function for the Q15 FIR lattice filter\&. 
.PP
\fBParameters:\fP
.RS 4
\fIS\fP points to an instance of the Q15 FIR lattice structure\&. 
.br
\fIpSrc\fP points to the block of input data\&. 
.br
\fIpDst\fP points to the block of output data\&. 
.br
\fIblockSize\fP number of samples to process\&. 
.RE
.PP

.SS "void arm_fir_lattice_q31 (const \fBarm_fir_lattice_instance_q31\fP * S, \fBq31_t\fP * pSrc, \fBq31_t\fP * pDst, uint32_t blockSize)"

.PP
Processing function for the Q31 FIR lattice filter\&. 
.PP
\fBParameters:\fP
.RS 4
\fIS\fP points to an instance of the Q31 FIR lattice structure\&. 
.br
\fIpSrc\fP points to the block of input data\&. 
.br
\fIpDst\fP points to the block of output data 
.br
\fIblockSize\fP number of samples to process\&. 
.RE
.PP

.SS "void arm_fir_q15 (const \fBarm_fir_instance_q15\fP * S, \fBq15_t\fP * pSrc, \fBq15_t\fP * pDst, uint32_t blockSize)"

.PP
Processing function for the Q15 FIR filter\&. 
.PP
\fBParameters:\fP
.RS 4
\fIS\fP points to an instance of the Q15 FIR structure\&. 
.br
\fIpSrc\fP points to the block of input data\&. 
.br
\fIpDst\fP points to the block of output data\&. 
.br
\fIblockSize\fP number of samples to process\&. 
.RE
.PP

.SS "void arm_fir_q31 (const \fBarm_fir_instance_q31\fP * S, \fBq31_t\fP * pSrc, \fBq31_t\fP * pDst, uint32_t blockSize)"

.PP
Processing function for the Q31 FIR filter\&. 
.PP
\fBParameters:\fP
.RS 4
\fIS\fP points to an instance of the Q31 FIR filter structure\&. 
.br
\fIpSrc\fP points to the block of input data\&. 
.br
\fIpDst\fP points to the block of output data\&. 
.br
\fIblockSize\fP number of samples to process\&. 
.RE
.PP

.SS "void arm_fir_q7 (const \fBarm_fir_instance_q7\fP * S, \fBq7_t\fP * pSrc, \fBq7_t\fP * pDst, uint32_t blockSize)"

.PP
Processing function for the Q7 FIR filter\&. 
.PP
\fBParameters:\fP
.RS 4
\fIS\fP points to an instance of the Q7 FIR filter structure\&. 
.br
\fIpSrc\fP points to the block of input data\&. 
.br
\fIpDst\fP points to the block of output data\&. 
.br
\fIblockSize\fP number of samples to process\&. 
.RE
.PP

.SS "void arm_fir_sparse_f32 (\fBarm_fir_sparse_instance_f32\fP * S, \fBfloat32_t\fP * pSrc, \fBfloat32_t\fP * pDst, \fBfloat32_t\fP * pScratchIn, uint32_t blockSize)"

.PP
Processing function for the floating-point sparse FIR filter\&. 
.PP
\fBParameters:\fP
.RS 4
\fIS\fP points to an instance of the floating-point sparse FIR structure\&. 
.br
\fIpSrc\fP points to the block of input data\&. 
.br
\fIpDst\fP points to the block of output data 
.br
\fIpScratchIn\fP points to a temporary buffer of size blockSize\&. 
.br
\fIblockSize\fP number of input samples to process per call\&. 
.RE
.PP

.SS "void arm_fir_sparse_init_f32 (\fBarm_fir_sparse_instance_f32\fP * S, uint16_t numTaps, \fBfloat32_t\fP * pCoeffs, \fBfloat32_t\fP * pState, int32_t * pTapDelay, uint16_t maxDelay, uint32_t blockSize)"

.PP
Initialization function for the floating-point sparse FIR filter\&. 
.PP
\fBParameters:\fP
.RS 4
\fIS\fP points to an instance of the floating-point sparse FIR structure\&. 
.br
\fInumTaps\fP number of nonzero coefficients in the filter\&. 
.br
\fIpCoeffs\fP points to the array of filter coefficients\&. 
.br
\fIpState\fP points to the state buffer\&. 
.br
\fIpTapDelay\fP points to the array of offset times\&. 
.br
\fImaxDelay\fP maximum offset time supported\&. 
.br
\fIblockSize\fP number of samples that will be processed per block\&. 
.RE
.PP

.SS "void arm_fir_sparse_init_q15 (\fBarm_fir_sparse_instance_q15\fP * S, uint16_t numTaps, \fBq15_t\fP * pCoeffs, \fBq15_t\fP * pState, int32_t * pTapDelay, uint16_t maxDelay, uint32_t blockSize)"

.PP
Initialization function for the Q15 sparse FIR filter\&. 
.PP
\fBParameters:\fP
.RS 4
\fIS\fP points to an instance of the Q15 sparse FIR structure\&. 
.br
\fInumTaps\fP number of nonzero coefficients in the filter\&. 
.br
\fIpCoeffs\fP points to the array of filter coefficients\&. 
.br
\fIpState\fP points to the state buffer\&. 
.br
\fIpTapDelay\fP points to the array of offset times\&. 
.br
\fImaxDelay\fP maximum offset time supported\&. 
.br
\fIblockSize\fP number of samples that will be processed per block\&. 
.RE
.PP

.SS "void arm_fir_sparse_init_q31 (\fBarm_fir_sparse_instance_q31\fP * S, uint16_t numTaps, \fBq31_t\fP * pCoeffs, \fBq31_t\fP * pState, int32_t * pTapDelay, uint16_t maxDelay, uint32_t blockSize)"

.PP
Initialization function for the Q31 sparse FIR filter\&. 
.PP
\fBParameters:\fP
.RS 4
\fIS\fP points to an instance of the Q31 sparse FIR structure\&. 
.br
\fInumTaps\fP number of nonzero coefficients in the filter\&. 
.br
\fIpCoeffs\fP points to the array of filter coefficients\&. 
.br
\fIpState\fP points to the state buffer\&. 
.br
\fIpTapDelay\fP points to the array of offset times\&. 
.br
\fImaxDelay\fP maximum offset time supported\&. 
.br
\fIblockSize\fP number of samples that will be processed per block\&. 
.RE
.PP

.SS "void arm_fir_sparse_init_q7 (\fBarm_fir_sparse_instance_q7\fP * S, uint16_t numTaps, \fBq7_t\fP * pCoeffs, \fBq7_t\fP * pState, int32_t * pTapDelay, uint16_t maxDelay, uint32_t blockSize)"

.PP
Initialization function for the Q7 sparse FIR filter\&. 
.PP
\fBParameters:\fP
.RS 4
\fIS\fP points to an instance of the Q7 sparse FIR structure\&. 
.br
\fInumTaps\fP number of nonzero coefficients in the filter\&. 
.br
\fIpCoeffs\fP points to the array of filter coefficients\&. 
.br
\fIpState\fP points to the state buffer\&. 
.br
\fIpTapDelay\fP points to the array of offset times\&. 
.br
\fImaxDelay\fP maximum offset time supported\&. 
.br
\fIblockSize\fP number of samples that will be processed per block\&. 
.RE
.PP

.SS "void arm_fir_sparse_q15 (\fBarm_fir_sparse_instance_q15\fP * S, \fBq15_t\fP * pSrc, \fBq15_t\fP * pDst, \fBq15_t\fP * pScratchIn, \fBq31_t\fP * pScratchOut, uint32_t blockSize)"

.PP
Processing function for the Q15 sparse FIR filter\&. 
.PP
\fBParameters:\fP
.RS 4
\fIS\fP points to an instance of the Q15 sparse FIR structure\&. 
.br
\fIpSrc\fP points to the block of input data\&. 
.br
\fIpDst\fP points to the block of output data 
.br
\fIpScratchIn\fP points to a temporary buffer of size blockSize\&. 
.br
\fIpScratchOut\fP points to a temporary buffer of size blockSize\&. 
.br
\fIblockSize\fP number of input samples to process per call\&. 
.RE
.PP

.SS "void arm_fir_sparse_q31 (\fBarm_fir_sparse_instance_q31\fP * S, \fBq31_t\fP * pSrc, \fBq31_t\fP * pDst, \fBq31_t\fP * pScratchIn, uint32_t blockSize)"

.PP
Processing function for the Q31 sparse FIR filter\&. 
.PP
\fBParameters:\fP
.RS 4
\fIS\fP points to an instance of the Q31 sparse FIR structure\&. 
.br
\fIpSrc\fP points to the block of input data\&. 
.br
\fIpDst\fP points to the block of output data 
.br
\fIpScratchIn\fP points to a temporary buffer of size blockSize\&. 
.br
\fIblockSize\fP number of input samples to process per call\&. 
.RE
.PP

.SS "void arm_fir_sparse_q7 (\fBarm_fir_sparse_instance_q7\fP * S, \fBq7_t\fP * pSrc, \fBq7_t\fP * pDst, \fBq7_t\fP * pScratchIn, \fBq31_t\fP * pScratchOut, uint32_t blockSize)"

.PP
Processing function for the Q7 sparse FIR filter\&. 
.PP
\fBParameters:\fP
.RS 4
\fIS\fP points to an instance of the Q7 sparse FIR structure\&. 
.br
\fIpSrc\fP points to the block of input data\&. 
.br
\fIpDst\fP points to the block of output data 
.br
\fIpScratchIn\fP points to a temporary buffer of size blockSize\&. 
.br
\fIpScratchOut\fP points to a temporary buffer of size blockSize\&. 
.br
\fIblockSize\fP number of input samples to process per call\&. 
.RE
.PP

.SS "void arm_float_to_q15 (\fBfloat32_t\fP * pSrc, \fBq15_t\fP * pDst, uint32_t blockSize)"

.PP
Converts the elements of the floating-point vector to Q15 vector\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrc\fP points to the floating-point input vector 
.br
\fIpDst\fP points to the Q15 output vector 
.br
\fIblockSize\fP length of the input vector 
.RE
.PP

.SS "void arm_float_to_q31 (\fBfloat32_t\fP * pSrc, \fBq31_t\fP * pDst, uint32_t blockSize)"

.PP
Converts the elements of the floating-point vector to Q31 vector\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrc\fP points to the floating-point input vector 
.br
\fIpDst\fP points to the Q31 output vector 
.br
\fIblockSize\fP length of the input vector 
.RE
.PP

.SS "void arm_float_to_q7 (\fBfloat32_t\fP * pSrc, \fBq7_t\fP * pDst, uint32_t blockSize)"

.PP
Converts the elements of the floating-point vector to Q7 vector\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrc\fP points to the floating-point input vector 
.br
\fIpDst\fP points to the Q7 output vector 
.br
\fIblockSize\fP length of the input vector 
.RE
.PP

.SS "void arm_iir_lattice_f32 (const \fBarm_iir_lattice_instance_f32\fP * S, \fBfloat32_t\fP * pSrc, \fBfloat32_t\fP * pDst, uint32_t blockSize)"

.PP
Processing function for the floating-point IIR lattice filter\&. 
.PP
\fBParameters:\fP
.RS 4
\fIS\fP points to an instance of the floating-point IIR lattice structure\&. 
.br
\fIpSrc\fP points to the block of input data\&. 
.br
\fIpDst\fP points to the block of output data\&. 
.br
\fIblockSize\fP number of samples to process\&. 
.RE
.PP

.SS "void arm_iir_lattice_init_f32 (\fBarm_iir_lattice_instance_f32\fP * S, uint16_t numStages, \fBfloat32_t\fP * pkCoeffs, \fBfloat32_t\fP * pvCoeffs, \fBfloat32_t\fP * pState, uint32_t blockSize)"

.PP
Initialization function for the floating-point IIR lattice filter\&. 
.PP
\fBParameters:\fP
.RS 4
\fIS\fP points to an instance of the floating-point IIR lattice structure\&. 
.br
\fInumStages\fP number of stages in the filter\&. 
.br
\fIpkCoeffs\fP points to the reflection coefficient buffer\&. The array is of length numStages\&. 
.br
\fIpvCoeffs\fP points to the ladder coefficient buffer\&. The array is of length numStages+1\&. 
.br
\fIpState\fP points to the state buffer\&. The array is of length numStages+blockSize-1\&. 
.br
\fIblockSize\fP number of samples to process\&. 
.RE
.PP

.SS "void arm_iir_lattice_init_q15 (\fBarm_iir_lattice_instance_q15\fP * S, uint16_t numStages, \fBq15_t\fP * pkCoeffs, \fBq15_t\fP * pvCoeffs, \fBq15_t\fP * pState, uint32_t blockSize)"

.PP
Initialization function for the Q15 IIR lattice filter\&. 
.PP
\fBParameters:\fP
.RS 4
\fIS\fP points to an instance of the fixed-point Q15 IIR lattice structure\&. 
.br
\fInumStages\fP number of stages in the filter\&. 
.br
\fIpkCoeffs\fP points to reflection coefficient buffer\&. The array is of length numStages\&. 
.br
\fIpvCoeffs\fP points to ladder coefficient buffer\&. The array is of length numStages+1\&. 
.br
\fIpState\fP points to state buffer\&. The array is of length numStages+blockSize\&. 
.br
\fIblockSize\fP number of samples to process per call\&. 
.RE
.PP

.SS "void arm_iir_lattice_init_q31 (\fBarm_iir_lattice_instance_q31\fP * S, uint16_t numStages, \fBq31_t\fP * pkCoeffs, \fBq31_t\fP * pvCoeffs, \fBq31_t\fP * pState, uint32_t blockSize)"

.PP
Initialization function for the Q31 IIR lattice filter\&. 
.PP
\fBParameters:\fP
.RS 4
\fIS\fP points to an instance of the Q31 IIR lattice structure\&. 
.br
\fInumStages\fP number of stages in the filter\&. 
.br
\fIpkCoeffs\fP points to the reflection coefficient buffer\&. The array is of length numStages\&. 
.br
\fIpvCoeffs\fP points to the ladder coefficient buffer\&. The array is of length numStages+1\&. 
.br
\fIpState\fP points to the state buffer\&. The array is of length numStages+blockSize\&. 
.br
\fIblockSize\fP number of samples to process\&. 
.RE
.PP

.SS "void arm_iir_lattice_q15 (const \fBarm_iir_lattice_instance_q15\fP * S, \fBq15_t\fP * pSrc, \fBq15_t\fP * pDst, uint32_t blockSize)"

.PP
Processing function for the Q15 IIR lattice filter\&. 
.PP
\fBParameters:\fP
.RS 4
\fIS\fP points to an instance of the Q15 IIR lattice structure\&. 
.br
\fIpSrc\fP points to the block of input data\&. 
.br
\fIpDst\fP points to the block of output data\&. 
.br
\fIblockSize\fP number of samples to process\&. 
.RE
.PP

.SS "void arm_iir_lattice_q31 (const \fBarm_iir_lattice_instance_q31\fP * S, \fBq31_t\fP * pSrc, \fBq31_t\fP * pDst, uint32_t blockSize)"

.PP
Processing function for the Q31 IIR lattice filter\&. 
.PP
\fBParameters:\fP
.RS 4
\fIS\fP points to an instance of the Q31 IIR lattice structure\&. 
.br
\fIpSrc\fP points to the block of input data\&. 
.br
\fIpDst\fP points to the block of output data\&. 
.br
\fIblockSize\fP number of samples to process\&. 
.RE
.PP

.SS "void arm_lms_f32 (const \fBarm_lms_instance_f32\fP * S, \fBfloat32_t\fP * pSrc, \fBfloat32_t\fP * pRef, \fBfloat32_t\fP * pOut, \fBfloat32_t\fP * pErr, uint32_t blockSize)"

.PP
Processing function for floating-point LMS filter\&. 
.PP
\fBParameters:\fP
.RS 4
\fIS\fP points to an instance of the floating-point LMS filter structure\&. 
.br
\fIpSrc\fP points to the block of input data\&. 
.br
\fIpRef\fP points to the block of reference data\&. 
.br
\fIpOut\fP points to the block of output data\&. 
.br
\fIpErr\fP points to the block of error data\&. 
.br
\fIblockSize\fP number of samples to process\&. 
.RE
.PP

.SS "void arm_lms_init_f32 (\fBarm_lms_instance_f32\fP * S, uint16_t numTaps, \fBfloat32_t\fP * pCoeffs, \fBfloat32_t\fP * pState, \fBfloat32_t\fP mu, uint32_t blockSize)"

.PP
Initialization function for floating-point LMS filter\&. 
.PP
\fBParameters:\fP
.RS 4
\fIS\fP points to an instance of the floating-point LMS filter structure\&. 
.br
\fInumTaps\fP number of filter coefficients\&. 
.br
\fIpCoeffs\fP points to the coefficient buffer\&. 
.br
\fIpState\fP points to state buffer\&. 
.br
\fImu\fP step size that controls filter coefficient updates\&. 
.br
\fIblockSize\fP number of samples to process\&. 
.RE
.PP

.SS "void arm_lms_init_q15 (\fBarm_lms_instance_q15\fP * S, uint16_t numTaps, \fBq15_t\fP * pCoeffs, \fBq15_t\fP * pState, \fBq15_t\fP mu, uint32_t blockSize, uint32_t postShift)"

.PP
Initialization function for the Q15 LMS filter\&. 
.PP
\fBParameters:\fP
.RS 4
\fIS\fP points to an instance of the Q15 LMS filter structure\&. 
.br
\fInumTaps\fP number of filter coefficients\&. 
.br
\fIpCoeffs\fP points to the coefficient buffer\&. 
.br
\fIpState\fP points to the state buffer\&. 
.br
\fImu\fP step size that controls filter coefficient updates\&. 
.br
\fIblockSize\fP number of samples to process\&. 
.br
\fIpostShift\fP bit shift applied to coefficients\&. 
.RE
.PP

.SS "void arm_lms_init_q31 (\fBarm_lms_instance_q31\fP * S, uint16_t numTaps, \fBq31_t\fP * pCoeffs, \fBq31_t\fP * pState, \fBq31_t\fP mu, uint32_t blockSize, uint32_t postShift)"

.PP
Initialization function for Q31 LMS filter\&. 
.PP
\fBParameters:\fP
.RS 4
\fIS\fP points to an instance of the Q31 LMS filter structure\&. 
.br
\fInumTaps\fP number of filter coefficients\&. 
.br
\fIpCoeffs\fP points to coefficient buffer\&. 
.br
\fIpState\fP points to state buffer\&. 
.br
\fImu\fP step size that controls filter coefficient updates\&. 
.br
\fIblockSize\fP number of samples to process\&. 
.br
\fIpostShift\fP bit shift applied to coefficients\&. 
.RE
.PP

.SS "void arm_lms_norm_f32 (\fBarm_lms_norm_instance_f32\fP * S, \fBfloat32_t\fP * pSrc, \fBfloat32_t\fP * pRef, \fBfloat32_t\fP * pOut, \fBfloat32_t\fP * pErr, uint32_t blockSize)"

.PP
Processing function for floating-point normalized LMS filter\&. 
.PP
\fBParameters:\fP
.RS 4
\fIS\fP points to an instance of the floating-point normalized LMS filter structure\&. 
.br
\fIpSrc\fP points to the block of input data\&. 
.br
\fIpRef\fP points to the block of reference data\&. 
.br
\fIpOut\fP points to the block of output data\&. 
.br
\fIpErr\fP points to the block of error data\&. 
.br
\fIblockSize\fP number of samples to process\&. 
.RE
.PP

.SS "void arm_lms_norm_init_f32 (\fBarm_lms_norm_instance_f32\fP * S, uint16_t numTaps, \fBfloat32_t\fP * pCoeffs, \fBfloat32_t\fP * pState, \fBfloat32_t\fP mu, uint32_t blockSize)"

.PP
Initialization function for floating-point normalized LMS filter\&. 
.PP
\fBParameters:\fP
.RS 4
\fIS\fP points to an instance of the floating-point LMS filter structure\&. 
.br
\fInumTaps\fP number of filter coefficients\&. 
.br
\fIpCoeffs\fP points to coefficient buffer\&. 
.br
\fIpState\fP points to state buffer\&. 
.br
\fImu\fP step size that controls filter coefficient updates\&. 
.br
\fIblockSize\fP number of samples to process\&. 
.RE
.PP

.SS "void arm_lms_norm_init_q15 (\fBarm_lms_norm_instance_q15\fP * S, uint16_t numTaps, \fBq15_t\fP * pCoeffs, \fBq15_t\fP * pState, \fBq15_t\fP mu, uint32_t blockSize, uint8_t postShift)"

.PP
Initialization function for Q15 normalized LMS filter\&. 
.PP
\fBParameters:\fP
.RS 4
\fIS\fP points to an instance of the Q15 normalized LMS filter structure\&. 
.br
\fInumTaps\fP number of filter coefficients\&. 
.br
\fIpCoeffs\fP points to coefficient buffer\&. 
.br
\fIpState\fP points to state buffer\&. 
.br
\fImu\fP step size that controls filter coefficient updates\&. 
.br
\fIblockSize\fP number of samples to process\&. 
.br
\fIpostShift\fP bit shift applied to coefficients\&. 
.RE
.PP

.SS "void arm_lms_norm_init_q31 (\fBarm_lms_norm_instance_q31\fP * S, uint16_t numTaps, \fBq31_t\fP * pCoeffs, \fBq31_t\fP * pState, \fBq31_t\fP mu, uint32_t blockSize, uint8_t postShift)"

.PP
Initialization function for Q31 normalized LMS filter\&. 
.PP
\fBParameters:\fP
.RS 4
\fIS\fP points to an instance of the Q31 normalized LMS filter structure\&. 
.br
\fInumTaps\fP number of filter coefficients\&. 
.br
\fIpCoeffs\fP points to coefficient buffer\&. 
.br
\fIpState\fP points to state buffer\&. 
.br
\fImu\fP step size that controls filter coefficient updates\&. 
.br
\fIblockSize\fP number of samples to process\&. 
.br
\fIpostShift\fP bit shift applied to coefficients\&. 
.RE
.PP

.SS "void arm_lms_norm_q15 (\fBarm_lms_norm_instance_q15\fP * S, \fBq15_t\fP * pSrc, \fBq15_t\fP * pRef, \fBq15_t\fP * pOut, \fBq15_t\fP * pErr, uint32_t blockSize)"

.PP
Processing function for Q15 normalized LMS filter\&. 
.PP
\fBParameters:\fP
.RS 4
\fIS\fP points to an instance of the Q15 normalized LMS filter structure\&. 
.br
\fIpSrc\fP points to the block of input data\&. 
.br
\fIpRef\fP points to the block of reference data\&. 
.br
\fIpOut\fP points to the block of output data\&. 
.br
\fIpErr\fP points to the block of error data\&. 
.br
\fIblockSize\fP number of samples to process\&. 
.RE
.PP

.SS "void arm_lms_norm_q31 (\fBarm_lms_norm_instance_q31\fP * S, \fBq31_t\fP * pSrc, \fBq31_t\fP * pRef, \fBq31_t\fP * pOut, \fBq31_t\fP * pErr, uint32_t blockSize)"

.PP
Processing function for Q31 normalized LMS filter\&. 
.PP
\fBParameters:\fP
.RS 4
\fIS\fP points to an instance of the Q31 normalized LMS filter structure\&. 
.br
\fIpSrc\fP points to the block of input data\&. 
.br
\fIpRef\fP points to the block of reference data\&. 
.br
\fIpOut\fP points to the block of output data\&. 
.br
\fIpErr\fP points to the block of error data\&. 
.br
\fIblockSize\fP number of samples to process\&. 
.RE
.PP

.SS "void arm_lms_q15 (const \fBarm_lms_instance_q15\fP * S, \fBq15_t\fP * pSrc, \fBq15_t\fP * pRef, \fBq15_t\fP * pOut, \fBq15_t\fP * pErr, uint32_t blockSize)"

.PP
Processing function for Q15 LMS filter\&. 
.PP
\fBParameters:\fP
.RS 4
\fIS\fP points to an instance of the Q15 LMS filter structure\&. 
.br
\fIpSrc\fP points to the block of input data\&. 
.br
\fIpRef\fP points to the block of reference data\&. 
.br
\fIpOut\fP points to the block of output data\&. 
.br
\fIpErr\fP points to the block of error data\&. 
.br
\fIblockSize\fP number of samples to process\&. 
.RE
.PP

.SS "void arm_lms_q31 (const \fBarm_lms_instance_q31\fP * S, \fBq31_t\fP * pSrc, \fBq31_t\fP * pRef, \fBq31_t\fP * pOut, \fBq31_t\fP * pErr, uint32_t blockSize)"

.PP
Processing function for Q31 LMS filter\&. 
.PP
\fBParameters:\fP
.RS 4
\fIS\fP points to an instance of the Q15 LMS filter structure\&. 
.br
\fIpSrc\fP points to the block of input data\&. 
.br
\fIpRef\fP points to the block of reference data\&. 
.br
\fIpOut\fP points to the block of output data\&. 
.br
\fIpErr\fP points to the block of error data\&. 
.br
\fIblockSize\fP number of samples to process\&. 
.RE
.PP

.SS "\fBarm_status\fP arm_mat_add_f32 (const \fBarm_matrix_instance_f32\fP * pSrcA, const \fBarm_matrix_instance_f32\fP * pSrcB, \fBarm_matrix_instance_f32\fP * pDst)"

.PP
Floating-point matrix addition\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrcA\fP points to the first input matrix structure 
.br
\fIpSrcB\fP points to the second input matrix structure 
.br
\fIpDst\fP points to output matrix structure 
.RE
.PP
\fBReturns:\fP
.RS 4
The function returns either \fCARM_MATH_SIZE_MISMATCH\fP or \fCARM_MATH_SUCCESS\fP based on the outcome of size checking\&. 
.RE
.PP

.SS "\fBarm_status\fP arm_mat_add_q15 (const \fBarm_matrix_instance_q15\fP * pSrcA, const \fBarm_matrix_instance_q15\fP * pSrcB, \fBarm_matrix_instance_q15\fP * pDst)"

.PP
Q15 matrix addition\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrcA\fP points to the first input matrix structure 
.br
\fIpSrcB\fP points to the second input matrix structure 
.br
\fIpDst\fP points to output matrix structure 
.RE
.PP
\fBReturns:\fP
.RS 4
The function returns either \fCARM_MATH_SIZE_MISMATCH\fP or \fCARM_MATH_SUCCESS\fP based on the outcome of size checking\&. 
.RE
.PP

.SS "\fBarm_status\fP arm_mat_add_q31 (const \fBarm_matrix_instance_q31\fP * pSrcA, const \fBarm_matrix_instance_q31\fP * pSrcB, \fBarm_matrix_instance_q31\fP * pDst)"

.PP
Q31 matrix addition\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrcA\fP points to the first input matrix structure 
.br
\fIpSrcB\fP points to the second input matrix structure 
.br
\fIpDst\fP points to output matrix structure 
.RE
.PP
\fBReturns:\fP
.RS 4
The function returns either \fCARM_MATH_SIZE_MISMATCH\fP or \fCARM_MATH_SUCCESS\fP based on the outcome of size checking\&. 
.RE
.PP

.SS "\fBarm_status\fP arm_mat_cmplx_mult_f32 (const \fBarm_matrix_instance_f32\fP * pSrcA, const \fBarm_matrix_instance_f32\fP * pSrcB, \fBarm_matrix_instance_f32\fP * pDst)"

.PP
Floating-point, complex, matrix multiplication\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrcA\fP points to the first input matrix structure 
.br
\fIpSrcB\fP points to the second input matrix structure 
.br
\fIpDst\fP points to output matrix structure 
.RE
.PP
\fBReturns:\fP
.RS 4
The function returns either \fCARM_MATH_SIZE_MISMATCH\fP or \fCARM_MATH_SUCCESS\fP based on the outcome of size checking\&. 
.RE
.PP

.SS "\fBarm_status\fP arm_mat_cmplx_mult_q15 (const \fBarm_matrix_instance_q15\fP * pSrcA, const \fBarm_matrix_instance_q15\fP * pSrcB, \fBarm_matrix_instance_q15\fP * pDst, \fBq15_t\fP * pScratch)"

.PP
Q15, complex, matrix multiplication\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrcA\fP points to the first input matrix structure 
.br
\fIpSrcB\fP points to the second input matrix structure 
.br
\fIpDst\fP points to output matrix structure 
.RE
.PP
\fBReturns:\fP
.RS 4
The function returns either \fCARM_MATH_SIZE_MISMATCH\fP or \fCARM_MATH_SUCCESS\fP based on the outcome of size checking\&. 
.RE
.PP

.SS "\fBarm_status\fP arm_mat_cmplx_mult_q31 (const \fBarm_matrix_instance_q31\fP * pSrcA, const \fBarm_matrix_instance_q31\fP * pSrcB, \fBarm_matrix_instance_q31\fP * pDst)"

.PP
Q31, complex, matrix multiplication\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrcA\fP points to the first input matrix structure 
.br
\fIpSrcB\fP points to the second input matrix structure 
.br
\fIpDst\fP points to output matrix structure 
.RE
.PP
\fBReturns:\fP
.RS 4
The function returns either \fCARM_MATH_SIZE_MISMATCH\fP or \fCARM_MATH_SUCCESS\fP based on the outcome of size checking\&. 
.RE
.PP

.SS "void arm_mat_init_f32 (\fBarm_matrix_instance_f32\fP * S, uint16_t nRows, uint16_t nColumns, \fBfloat32_t\fP * pData)"

.PP
Floating-point matrix initialization\&. 
.PP
\fBParameters:\fP
.RS 4
\fIS\fP points to an instance of the floating-point matrix structure\&. 
.br
\fInRows\fP number of rows in the matrix\&. 
.br
\fInColumns\fP number of columns in the matrix\&. 
.br
\fIpData\fP points to the matrix data array\&. 
.RE
.PP

.SS "void arm_mat_init_q15 (\fBarm_matrix_instance_q15\fP * S, uint16_t nRows, uint16_t nColumns, \fBq15_t\fP * pData)"

.PP
Q15 matrix initialization\&. 
.PP
\fBParameters:\fP
.RS 4
\fIS\fP points to an instance of the floating-point matrix structure\&. 
.br
\fInRows\fP number of rows in the matrix\&. 
.br
\fInColumns\fP number of columns in the matrix\&. 
.br
\fIpData\fP points to the matrix data array\&. 
.RE
.PP

.SS "void arm_mat_init_q31 (\fBarm_matrix_instance_q31\fP * S, uint16_t nRows, uint16_t nColumns, \fBq31_t\fP * pData)"

.PP
Q31 matrix initialization\&. 
.PP
\fBParameters:\fP
.RS 4
\fIS\fP points to an instance of the floating-point matrix structure\&. 
.br
\fInRows\fP number of rows in the matrix\&. 
.br
\fInColumns\fP number of columns in the matrix\&. 
.br
\fIpData\fP points to the matrix data array\&. 
.RE
.PP

.SS "\fBarm_status\fP arm_mat_inverse_f32 (const \fBarm_matrix_instance_f32\fP * src, \fBarm_matrix_instance_f32\fP * dst)"

.PP
Floating-point matrix inverse\&. end of PID group 
.PP
\fBParameters:\fP
.RS 4
\fIsrc\fP points to the instance of the input floating-point matrix structure\&. 
.br
\fIdst\fP points to the instance of the output floating-point matrix structure\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
The function returns ARM_MATH_SIZE_MISMATCH, if the dimensions do not match\&. If the input matrix is singular (does not have an inverse), then the algorithm terminates and returns error status ARM_MATH_SINGULAR\&. 
.RE
.PP

.SS "\fBarm_status\fP arm_mat_inverse_f64 (const \fBarm_matrix_instance_f64\fP * src, \fBarm_matrix_instance_f64\fP * dst)"

.PP
Floating-point matrix inverse\&. 
.PP
\fBParameters:\fP
.RS 4
\fIsrc\fP points to the instance of the input floating-point matrix structure\&. 
.br
\fIdst\fP points to the instance of the output floating-point matrix structure\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
The function returns ARM_MATH_SIZE_MISMATCH, if the dimensions do not match\&. If the input matrix is singular (does not have an inverse), then the algorithm terminates and returns error status ARM_MATH_SINGULAR\&. 
.RE
.PP

.SS "\fBarm_status\fP arm_mat_mult_f32 (const \fBarm_matrix_instance_f32\fP * pSrcA, const \fBarm_matrix_instance_f32\fP * pSrcB, \fBarm_matrix_instance_f32\fP * pDst)"

.PP
Floating-point matrix multiplication\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrcA\fP points to the first input matrix structure 
.br
\fIpSrcB\fP points to the second input matrix structure 
.br
\fIpDst\fP points to output matrix structure 
.RE
.PP
\fBReturns:\fP
.RS 4
The function returns either \fCARM_MATH_SIZE_MISMATCH\fP or \fCARM_MATH_SUCCESS\fP based on the outcome of size checking\&. 
.RE
.PP

.SS "\fBarm_status\fP arm_mat_mult_fast_q15 (const \fBarm_matrix_instance_q15\fP * pSrcA, const \fBarm_matrix_instance_q15\fP * pSrcB, \fBarm_matrix_instance_q15\fP * pDst, \fBq15_t\fP * pState)"

.PP
Q15 matrix multiplication (fast variant) for Cortex-M3 and Cortex-M4\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrcA\fP points to the first input matrix structure 
.br
\fIpSrcB\fP points to the second input matrix structure 
.br
\fIpDst\fP points to output matrix structure 
.br
\fIpState\fP points to the array for storing intermediate results 
.RE
.PP
\fBReturns:\fP
.RS 4
The function returns either \fCARM_MATH_SIZE_MISMATCH\fP or \fCARM_MATH_SUCCESS\fP based on the outcome of size checking\&. 
.RE
.PP

.SS "\fBarm_status\fP arm_mat_mult_fast_q31 (const \fBarm_matrix_instance_q31\fP * pSrcA, const \fBarm_matrix_instance_q31\fP * pSrcB, \fBarm_matrix_instance_q31\fP * pDst)"

.PP
Q31 matrix multiplication (fast variant) for Cortex-M3 and Cortex-M4\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrcA\fP points to the first input matrix structure 
.br
\fIpSrcB\fP points to the second input matrix structure 
.br
\fIpDst\fP points to output matrix structure 
.RE
.PP
\fBReturns:\fP
.RS 4
The function returns either \fCARM_MATH_SIZE_MISMATCH\fP or \fCARM_MATH_SUCCESS\fP based on the outcome of size checking\&. 
.RE
.PP

.SS "\fBarm_status\fP arm_mat_mult_q15 (const \fBarm_matrix_instance_q15\fP * pSrcA, const \fBarm_matrix_instance_q15\fP * pSrcB, \fBarm_matrix_instance_q15\fP * pDst, \fBq15_t\fP * pState)"

.PP
Q15 matrix multiplication\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrcA\fP points to the first input matrix structure 
.br
\fIpSrcB\fP points to the second input matrix structure 
.br
\fIpDst\fP points to output matrix structure 
.br
\fIpState\fP points to the array for storing intermediate results 
.RE
.PP
\fBReturns:\fP
.RS 4
The function returns either \fCARM_MATH_SIZE_MISMATCH\fP or \fCARM_MATH_SUCCESS\fP based on the outcome of size checking\&. 
.RE
.PP

.SS "\fBarm_status\fP arm_mat_mult_q31 (const \fBarm_matrix_instance_q31\fP * pSrcA, const \fBarm_matrix_instance_q31\fP * pSrcB, \fBarm_matrix_instance_q31\fP * pDst)"

.PP
Q31 matrix multiplication\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrcA\fP points to the first input matrix structure 
.br
\fIpSrcB\fP points to the second input matrix structure 
.br
\fIpDst\fP points to output matrix structure 
.RE
.PP
\fBReturns:\fP
.RS 4
The function returns either \fCARM_MATH_SIZE_MISMATCH\fP or \fCARM_MATH_SUCCESS\fP based on the outcome of size checking\&. 
.RE
.PP

.SS "\fBarm_status\fP arm_mat_scale_f32 (const \fBarm_matrix_instance_f32\fP * pSrc, \fBfloat32_t\fP scale, \fBarm_matrix_instance_f32\fP * pDst)"

.PP
Floating-point matrix scaling\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrc\fP points to the input matrix 
.br
\fIscale\fP scale factor 
.br
\fIpDst\fP points to the output matrix 
.RE
.PP
\fBReturns:\fP
.RS 4
The function returns either \fCARM_MATH_SIZE_MISMATCH\fP or \fCARM_MATH_SUCCESS\fP based on the outcome of size checking\&. 
.RE
.PP

.SS "\fBarm_status\fP arm_mat_scale_q15 (const \fBarm_matrix_instance_q15\fP * pSrc, \fBq15_t\fP scaleFract, int32_t shift, \fBarm_matrix_instance_q15\fP * pDst)"

.PP
Q15 matrix scaling\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrc\fP points to input matrix 
.br
\fIscaleFract\fP fractional portion of the scale factor 
.br
\fIshift\fP number of bits to shift the result by 
.br
\fIpDst\fP points to output matrix 
.RE
.PP
\fBReturns:\fP
.RS 4
The function returns either \fCARM_MATH_SIZE_MISMATCH\fP or \fCARM_MATH_SUCCESS\fP based on the outcome of size checking\&. 
.RE
.PP

.SS "\fBarm_status\fP arm_mat_scale_q31 (const \fBarm_matrix_instance_q31\fP * pSrc, \fBq31_t\fP scaleFract, int32_t shift, \fBarm_matrix_instance_q31\fP * pDst)"

.PP
Q31 matrix scaling\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrc\fP points to input matrix 
.br
\fIscaleFract\fP fractional portion of the scale factor 
.br
\fIshift\fP number of bits to shift the result by 
.br
\fIpDst\fP points to output matrix structure 
.RE
.PP
\fBReturns:\fP
.RS 4
The function returns either \fCARM_MATH_SIZE_MISMATCH\fP or \fCARM_MATH_SUCCESS\fP based on the outcome of size checking\&. 
.RE
.PP

.SS "\fBarm_status\fP arm_mat_sub_f32 (const \fBarm_matrix_instance_f32\fP * pSrcA, const \fBarm_matrix_instance_f32\fP * pSrcB, \fBarm_matrix_instance_f32\fP * pDst)"

.PP
Floating-point matrix subtraction\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrcA\fP points to the first input matrix structure 
.br
\fIpSrcB\fP points to the second input matrix structure 
.br
\fIpDst\fP points to output matrix structure 
.RE
.PP
\fBReturns:\fP
.RS 4
The function returns either \fCARM_MATH_SIZE_MISMATCH\fP or \fCARM_MATH_SUCCESS\fP based on the outcome of size checking\&. 
.RE
.PP

.SS "\fBarm_status\fP arm_mat_sub_q15 (const \fBarm_matrix_instance_q15\fP * pSrcA, const \fBarm_matrix_instance_q15\fP * pSrcB, \fBarm_matrix_instance_q15\fP * pDst)"

.PP
Q15 matrix subtraction\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrcA\fP points to the first input matrix structure 
.br
\fIpSrcB\fP points to the second input matrix structure 
.br
\fIpDst\fP points to output matrix structure 
.RE
.PP
\fBReturns:\fP
.RS 4
The function returns either \fCARM_MATH_SIZE_MISMATCH\fP or \fCARM_MATH_SUCCESS\fP based on the outcome of size checking\&. 
.RE
.PP

.SS "\fBarm_status\fP arm_mat_sub_q31 (const \fBarm_matrix_instance_q31\fP * pSrcA, const \fBarm_matrix_instance_q31\fP * pSrcB, \fBarm_matrix_instance_q31\fP * pDst)"

.PP
Q31 matrix subtraction\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrcA\fP points to the first input matrix structure 
.br
\fIpSrcB\fP points to the second input matrix structure 
.br
\fIpDst\fP points to output matrix structure 
.RE
.PP
\fBReturns:\fP
.RS 4
The function returns either \fCARM_MATH_SIZE_MISMATCH\fP or \fCARM_MATH_SUCCESS\fP based on the outcome of size checking\&. 
.RE
.PP

.SS "\fBarm_status\fP arm_mat_trans_f32 (const \fBarm_matrix_instance_f32\fP * pSrc, \fBarm_matrix_instance_f32\fP * pDst)"

.PP
Floating-point matrix transpose\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrc\fP points to the input matrix 
.br
\fIpDst\fP points to the output matrix 
.RE
.PP
\fBReturns:\fP
.RS 4
The function returns either \fCARM_MATH_SIZE_MISMATCH\fP or \fCARM_MATH_SUCCESS\fP based on the outcome of size checking\&. 
.RE
.PP

.SS "\fBarm_status\fP arm_mat_trans_q15 (const \fBarm_matrix_instance_q15\fP * pSrc, \fBarm_matrix_instance_q15\fP * pDst)"

.PP
Q15 matrix transpose\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrc\fP points to the input matrix 
.br
\fIpDst\fP points to the output matrix 
.RE
.PP
\fBReturns:\fP
.RS 4
The function returns either \fCARM_MATH_SIZE_MISMATCH\fP or \fCARM_MATH_SUCCESS\fP based on the outcome of size checking\&. 
.RE
.PP

.SS "\fBarm_status\fP arm_mat_trans_q31 (const \fBarm_matrix_instance_q31\fP * pSrc, \fBarm_matrix_instance_q31\fP * pDst)"

.PP
Q31 matrix transpose\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrc\fP points to the input matrix 
.br
\fIpDst\fP points to the output matrix 
.RE
.PP
\fBReturns:\fP
.RS 4
The function returns either \fCARM_MATH_SIZE_MISMATCH\fP or \fCARM_MATH_SUCCESS\fP based on the outcome of size checking\&. 
.RE
.PP

.SS "void arm_max_f32 (\fBfloat32_t\fP * pSrc, uint32_t blockSize, \fBfloat32_t\fP * pResult, uint32_t * pIndex)"

.PP
Maximum value of a floating-point vector\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrc\fP points to the input buffer 
.br
\fIblockSize\fP length of the input vector 
.br
\fIpResult\fP maximum value returned here 
.br
\fIpIndex\fP index of maximum value returned here 
.RE
.PP

.SS "void arm_max_q15 (\fBq15_t\fP * pSrc, uint32_t blockSize, \fBq15_t\fP * pResult, uint32_t * pIndex)"

.PP
Maximum value of a Q15 vector\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrc\fP points to the input buffer 
.br
\fIblockSize\fP length of the input vector 
.br
\fIpResult\fP maximum value returned here 
.br
\fIpIndex\fP index of maximum value returned here 
.RE
.PP

.SS "void arm_max_q31 (\fBq31_t\fP * pSrc, uint32_t blockSize, \fBq31_t\fP * pResult, uint32_t * pIndex)"

.PP
Maximum value of a Q31 vector\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrc\fP points to the input buffer 
.br
\fIblockSize\fP length of the input vector 
.br
\fIpResult\fP maximum value returned here 
.br
\fIpIndex\fP index of maximum value returned here 
.RE
.PP

.SS "void arm_max_q7 (\fBq7_t\fP * pSrc, uint32_t blockSize, \fBq7_t\fP * pResult, uint32_t * pIndex)"

.PP
Maximum value of a Q7 vector\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrc\fP points to the input buffer 
.br
\fIblockSize\fP length of the input vector 
.br
\fIpResult\fP maximum value returned here 
.br
\fIpIndex\fP index of maximum value returned here 
.RE
.PP

.SS "void arm_mean_f32 (\fBfloat32_t\fP * pSrc, uint32_t blockSize, \fBfloat32_t\fP * pResult)"

.PP
Mean value of a floating-point vector\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrc\fP is input pointer 
.br
\fIblockSize\fP is the number of samples to process 
.br
\fIpResult\fP is output value\&. 
.RE
.PP

.SS "void arm_mean_q15 (\fBq15_t\fP * pSrc, uint32_t blockSize, \fBq15_t\fP * pResult)"

.PP
Mean value of a Q15 vector\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrc\fP is input pointer 
.br
\fIblockSize\fP is the number of samples to process 
.br
\fIpResult\fP is output value\&. 
.RE
.PP

.SS "void arm_mean_q31 (\fBq31_t\fP * pSrc, uint32_t blockSize, \fBq31_t\fP * pResult)"

.PP
Mean value of a Q31 vector\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrc\fP is input pointer 
.br
\fIblockSize\fP is the number of samples to process 
.br
\fIpResult\fP is output value\&. 
.RE
.PP

.SS "void arm_mean_q7 (\fBq7_t\fP * pSrc, uint32_t blockSize, \fBq7_t\fP * pResult)"

.PP
Mean value of a Q7 vector\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrc\fP is input pointer 
.br
\fIblockSize\fP is the number of samples to process 
.br
\fIpResult\fP is output value\&. 
.RE
.PP

.SS "void arm_min_f32 (\fBfloat32_t\fP * pSrc, uint32_t blockSize, \fBfloat32_t\fP * pResult, uint32_t * pIndex)"

.PP
Minimum value of a floating-point vector\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrc\fP is input pointer 
.br
\fIblockSize\fP is the number of samples to process 
.br
\fIpResult\fP is output pointer 
.br
\fIpIndex\fP is the array index of the minimum value in the input buffer\&. 
.RE
.PP

.SS "void arm_min_q15 (\fBq15_t\fP * pSrc, uint32_t blockSize, \fBq15_t\fP * pResult, uint32_t * pIndex)"

.PP
Minimum value of a Q15 vector\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrc\fP is input pointer 
.br
\fIblockSize\fP is the number of samples to process 
.br
\fIpResult\fP is output pointer 
.br
\fIpIndex\fP is the array index of the minimum value in the input buffer\&. 
.RE
.PP

.SS "void arm_min_q31 (\fBq31_t\fP * pSrc, uint32_t blockSize, \fBq31_t\fP * pResult, uint32_t * pIndex)"

.PP
Minimum value of a Q31 vector\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrc\fP is input pointer 
.br
\fIblockSize\fP is the number of samples to process 
.br
\fIpResult\fP is output pointer 
.br
\fIpIndex\fP is the array index of the minimum value in the input buffer\&. 
.RE
.PP

.SS "void arm_min_q7 (\fBq7_t\fP * pSrc, uint32_t blockSize, \fBq7_t\fP * result, uint32_t * index)"

.PP
Minimum value of a Q7 vector\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrc\fP is input pointer 
.br
\fIblockSize\fP is the number of samples to process 
.br
\fIresult\fP is output pointer 
.br
\fIindex\fP is the array index of the minimum value in the input buffer\&. 
.RE
.PP

.SS "void arm_mult_f32 (\fBfloat32_t\fP * pSrcA, \fBfloat32_t\fP * pSrcB, \fBfloat32_t\fP * pDst, uint32_t blockSize)"

.PP
Floating-point vector multiplication\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrcA\fP points to the first input vector 
.br
\fIpSrcB\fP points to the second input vector 
.br
\fIpDst\fP points to the output vector 
.br
\fIblockSize\fP number of samples in each vector 
.RE
.PP

.SS "void arm_mult_q15 (\fBq15_t\fP * pSrcA, \fBq15_t\fP * pSrcB, \fBq15_t\fP * pDst, uint32_t blockSize)"

.PP
Q15 vector multiplication\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrcA\fP points to the first input vector 
.br
\fIpSrcB\fP points to the second input vector 
.br
\fIpDst\fP points to the output vector 
.br
\fIblockSize\fP number of samples in each vector 
.RE
.PP

.SS "void arm_mult_q31 (\fBq31_t\fP * pSrcA, \fBq31_t\fP * pSrcB, \fBq31_t\fP * pDst, uint32_t blockSize)"

.PP
Q31 vector multiplication\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrcA\fP points to the first input vector 
.br
\fIpSrcB\fP points to the second input vector 
.br
\fIpDst\fP points to the output vector 
.br
\fIblockSize\fP number of samples in each vector 
.RE
.PP

.SS "void arm_mult_q7 (\fBq7_t\fP * pSrcA, \fBq7_t\fP * pSrcB, \fBq7_t\fP * pDst, uint32_t blockSize)"

.PP
Q7 vector multiplication\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrcA\fP points to the first input vector 
.br
\fIpSrcB\fP points to the second input vector 
.br
\fIpDst\fP points to the output vector 
.br
\fIblockSize\fP number of samples in each vector 
.RE
.PP

.SS "void arm_negate_f32 (\fBfloat32_t\fP * pSrc, \fBfloat32_t\fP * pDst, uint32_t blockSize)"

.PP
Negates the elements of a floating-point vector\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrc\fP points to the input vector 
.br
\fIpDst\fP points to the output vector 
.br
\fIblockSize\fP number of samples in the vector 
.RE
.PP

.SS "void arm_negate_q15 (\fBq15_t\fP * pSrc, \fBq15_t\fP * pDst, uint32_t blockSize)"

.PP
Negates the elements of a Q15 vector\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrc\fP points to the input vector 
.br
\fIpDst\fP points to the output vector 
.br
\fIblockSize\fP number of samples in the vector 
.RE
.PP

.SS "void arm_negate_q31 (\fBq31_t\fP * pSrc, \fBq31_t\fP * pDst, uint32_t blockSize)"

.PP
Negates the elements of a Q31 vector\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrc\fP points to the input vector 
.br
\fIpDst\fP points to the output vector 
.br
\fIblockSize\fP number of samples in the vector 
.RE
.PP

.SS "void arm_negate_q7 (\fBq7_t\fP * pSrc, \fBq7_t\fP * pDst, uint32_t blockSize)"

.PP
Negates the elements of a Q7 vector\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrc\fP points to the input vector 
.br
\fIpDst\fP points to the output vector 
.br
\fIblockSize\fP number of samples in the vector 
.RE
.PP

.SS "void arm_offset_f32 (\fBfloat32_t\fP * pSrc, \fBfloat32_t\fP offset, \fBfloat32_t\fP * pDst, uint32_t blockSize)"

.PP
Adds a constant offset to a floating-point vector\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrc\fP points to the input vector 
.br
\fIoffset\fP is the offset to be added 
.br
\fIpDst\fP points to the output vector 
.br
\fIblockSize\fP number of samples in the vector 
.RE
.PP

.SS "void arm_offset_q15 (\fBq15_t\fP * pSrc, \fBq15_t\fP offset, \fBq15_t\fP * pDst, uint32_t blockSize)"

.PP
Adds a constant offset to a Q15 vector\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrc\fP points to the input vector 
.br
\fIoffset\fP is the offset to be added 
.br
\fIpDst\fP points to the output vector 
.br
\fIblockSize\fP number of samples in the vector 
.RE
.PP

.SS "void arm_offset_q31 (\fBq31_t\fP * pSrc, \fBq31_t\fP offset, \fBq31_t\fP * pDst, uint32_t blockSize)"

.PP
Adds a constant offset to a Q31 vector\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrc\fP points to the input vector 
.br
\fIoffset\fP is the offset to be added 
.br
\fIpDst\fP points to the output vector 
.br
\fIblockSize\fP number of samples in the vector 
.RE
.PP

.SS "void arm_offset_q7 (\fBq7_t\fP * pSrc, \fBq7_t\fP offset, \fBq7_t\fP * pDst, uint32_t blockSize)"

.PP
Adds a constant offset to a Q7 vector\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrc\fP points to the input vector 
.br
\fIoffset\fP is the offset to be added 
.br
\fIpDst\fP points to the output vector 
.br
\fIblockSize\fP number of samples in the vector 
.RE
.PP

.SS "void arm_pid_init_f32 (\fBarm_pid_instance_f32\fP * S, int32_t resetStateFlag)"

.PP
Initialization function for the floating-point PID Control\&. 
.PP
\fBParameters:\fP
.RS 4
\fIS\fP points to an instance of the PID structure\&. 
.br
\fIresetStateFlag\fP flag to reset the state\&. 0 = no change in state 1 = reset the state\&. 
.RE
.PP

.SS "void arm_pid_init_q15 (\fBarm_pid_instance_q15\fP * S, int32_t resetStateFlag)"

.PP
Initialization function for the Q15 PID Control\&. 
.PP
\fBParameters:\fP
.RS 4
\fIS\fP points to an instance of the Q15 PID structure\&. 
.br
\fIresetStateFlag\fP flag to reset the state\&. 0 = no change in state 1 = reset the state\&. 
.RE
.PP

.SS "void arm_pid_init_q31 (\fBarm_pid_instance_q31\fP * S, int32_t resetStateFlag)"

.PP
Initialization function for the Q31 PID Control\&. 
.PP
\fBParameters:\fP
.RS 4
\fIS\fP points to an instance of the Q15 PID structure\&. 
.br
\fIresetStateFlag\fP flag to reset the state\&. 0 = no change in state 1 = reset the state\&. 
.RE
.PP

.SS "void arm_pid_reset_f32 (\fBarm_pid_instance_f32\fP * S)"

.PP
Reset function for the floating-point PID Control\&. 
.PP
\fBParameters:\fP
.RS 4
\fIS\fP is an instance of the floating-point PID Control structure 
.RE
.PP

.SS "void arm_pid_reset_q15 (\fBarm_pid_instance_q15\fP * S)"

.PP
Reset function for the Q15 PID Control\&. 
.PP
\fBParameters:\fP
.RS 4
\fIS\fP points to an instance of the q15 PID Control structure 
.RE
.PP

.SS "void arm_pid_reset_q31 (\fBarm_pid_instance_q31\fP * S)"

.PP
Reset function for the Q31 PID Control\&. 
.PP
\fBParameters:\fP
.RS 4
\fIS\fP points to an instance of the Q31 PID Control structure 
.RE
.PP

.SS "void arm_power_f32 (\fBfloat32_t\fP * pSrc, uint32_t blockSize, \fBfloat32_t\fP * pResult)"

.PP
Sum of the squares of the elements of a floating-point vector\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrc\fP is input pointer 
.br
\fIblockSize\fP is the number of samples to process 
.br
\fIpResult\fP is output value\&. 
.RE
.PP

.SS "void arm_power_q15 (\fBq15_t\fP * pSrc, uint32_t blockSize, \fBq63_t\fP * pResult)"

.PP
Sum of the squares of the elements of a Q15 vector\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrc\fP is input pointer 
.br
\fIblockSize\fP is the number of samples to process 
.br
\fIpResult\fP is output value\&. 
.RE
.PP

.SS "void arm_power_q31 (\fBq31_t\fP * pSrc, uint32_t blockSize, \fBq63_t\fP * pResult)"

.PP
Sum of the squares of the elements of a Q31 vector\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrc\fP is input pointer 
.br
\fIblockSize\fP is the number of samples to process 
.br
\fIpResult\fP is output value\&. 
.RE
.PP

.SS "void arm_power_q7 (\fBq7_t\fP * pSrc, uint32_t blockSize, \fBq31_t\fP * pResult)"

.PP
Sum of the squares of the elements of a Q7 vector\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrc\fP is input pointer 
.br
\fIblockSize\fP is the number of samples to process 
.br
\fIpResult\fP is output value\&. 
.RE
.PP

.SS "void arm_q15_to_float (\fBq15_t\fP * pSrc, \fBfloat32_t\fP * pDst, uint32_t blockSize)"

.PP
Converts the elements of the Q15 vector to floating-point vector\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrc\fP is input pointer 
.br
\fIpDst\fP is output pointer 
.br
\fIblockSize\fP is the number of samples to process 
.RE
.PP

.SS "void arm_q15_to_q31 (\fBq15_t\fP * pSrc, \fBq31_t\fP * pDst, uint32_t blockSize)"

.PP
Converts the elements of the Q15 vector to Q31 vector\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrc\fP is input pointer 
.br
\fIpDst\fP is output pointer 
.br
\fIblockSize\fP is the number of samples to process 
.RE
.PP

.SS "void arm_q15_to_q7 (\fBq15_t\fP * pSrc, \fBq7_t\fP * pDst, uint32_t blockSize)"

.PP
Converts the elements of the Q15 vector to Q7 vector\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrc\fP is input pointer 
.br
\fIpDst\fP is output pointer 
.br
\fIblockSize\fP is the number of samples to process 
.RE
.PP

.SS "void arm_q31_to_float (\fBq31_t\fP * pSrc, \fBfloat32_t\fP * pDst, uint32_t blockSize)"

.PP
Converts the elements of the Q31 vector to floating-point vector\&. end of Inverse park group 
.PP
\fBParameters:\fP
.RS 4
\fIpSrc\fP is input pointer 
.br
\fIpDst\fP is output pointer 
.br
\fIblockSize\fP is the number of samples to process 
.RE
.PP

.SS "void arm_q31_to_q15 (\fBq31_t\fP * pSrc, \fBq15_t\fP * pDst, uint32_t blockSize)"

.PP
Converts the elements of the Q31 vector to Q15 vector\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrc\fP is input pointer 
.br
\fIpDst\fP is output pointer 
.br
\fIblockSize\fP is the number of samples to process 
.RE
.PP

.SS "void arm_q31_to_q7 (\fBq31_t\fP * pSrc, \fBq7_t\fP * pDst, uint32_t blockSize)"

.PP
Converts the elements of the Q31 vector to Q7 vector\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrc\fP is input pointer 
.br
\fIpDst\fP is output pointer 
.br
\fIblockSize\fP is the number of samples to process 
.RE
.PP

.SS "void arm_q7_to_float (\fBq7_t\fP * pSrc, \fBfloat32_t\fP * pDst, uint32_t blockSize)"

.PP
Converts the elements of the Q7 vector to floating-point vector\&. end of park group 
.PP
\fBParameters:\fP
.RS 4
\fIpSrc\fP is input pointer 
.br
\fIpDst\fP is output pointer 
.br
\fIblockSize\fP is the number of samples to process 
.RE
.PP

.SS "void arm_q7_to_q15 (\fBq7_t\fP * pSrc, \fBq15_t\fP * pDst, uint32_t blockSize)"

.PP
Converts the elements of the Q7 vector to Q15 vector\&. end of inv_clarke group 
.PP
\fBParameters:\fP
.RS 4
\fIpSrc\fP input pointer 
.br
\fIpDst\fP output pointer 
.br
\fIblockSize\fP number of samples to process 
.RE
.PP

.SS "void arm_q7_to_q31 (\fBq7_t\fP * pSrc, \fBq31_t\fP * pDst, uint32_t blockSize)"

.PP
Converts the elements of the Q7 vector to Q31 vector\&. end of clarke group 
.PP
\fBParameters:\fP
.RS 4
\fIpSrc\fP input pointer 
.br
\fIpDst\fP output pointer 
.br
\fIblockSize\fP number of samples to process 
.RE
.PP

.SS "void arm_rfft_f32 (const \fBarm_rfft_instance_f32\fP * S, \fBfloat32_t\fP * pSrc, \fBfloat32_t\fP * pDst)"

.SS "void arm_rfft_fast_f32 (\fBarm_rfft_fast_instance_f32\fP * S, \fBfloat32_t\fP * p, \fBfloat32_t\fP * pOut, uint8_t ifftFlag)"

.SS "\fBarm_status\fP arm_rfft_fast_init_f32 (\fBarm_rfft_fast_instance_f32\fP * S, uint16_t fftLen)"

.SS "\fBarm_status\fP arm_rfft_init_f32 (\fBarm_rfft_instance_f32\fP * S, \fBarm_cfft_radix4_instance_f32\fP * S_CFFT, uint32_t fftLenReal, uint32_t ifftFlagR, uint32_t bitReverseFlag)"

.SS "\fBarm_status\fP arm_rfft_init_q15 (\fBarm_rfft_instance_q15\fP * S, uint32_t fftLenReal, uint32_t ifftFlagR, uint32_t bitReverseFlag)"

.SS "\fBarm_status\fP arm_rfft_init_q31 (\fBarm_rfft_instance_q31\fP * S, uint32_t fftLenReal, uint32_t ifftFlagR, uint32_t bitReverseFlag)"

.SS "void arm_rfft_q15 (const \fBarm_rfft_instance_q15\fP * S, \fBq15_t\fP * pSrc, \fBq15_t\fP * pDst)"

.SS "void arm_rfft_q31 (const \fBarm_rfft_instance_q31\fP * S, \fBq31_t\fP * pSrc, \fBq31_t\fP * pDst)"

.SS "void arm_rms_f32 (\fBfloat32_t\fP * pSrc, uint32_t blockSize, \fBfloat32_t\fP * pResult)"

.PP
Root Mean Square of the elements of a floating-point vector\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrc\fP is input pointer 
.br
\fIblockSize\fP is the number of samples to process 
.br
\fIpResult\fP is output value\&. 
.RE
.PP

.SS "void arm_rms_q15 (\fBq15_t\fP * pSrc, uint32_t blockSize, \fBq15_t\fP * pResult)"

.PP
Root Mean Square of the elements of a Q15 vector\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrc\fP is input pointer 
.br
\fIblockSize\fP is the number of samples to process 
.br
\fIpResult\fP is output value\&. 
.RE
.PP

.SS "void arm_rms_q31 (\fBq31_t\fP * pSrc, uint32_t blockSize, \fBq31_t\fP * pResult)"

.PP
Root Mean Square of the elements of a Q31 vector\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrc\fP is input pointer 
.br
\fIblockSize\fP is the number of samples to process 
.br
\fIpResult\fP is output value\&. 
.RE
.PP

.SS "void arm_scale_f32 (\fBfloat32_t\fP * pSrc, \fBfloat32_t\fP scale, \fBfloat32_t\fP * pDst, uint32_t blockSize)"

.PP
Multiplies a floating-point vector by a scalar\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrc\fP points to the input vector 
.br
\fIscale\fP scale factor to be applied 
.br
\fIpDst\fP points to the output vector 
.br
\fIblockSize\fP number of samples in the vector 
.RE
.PP

.SS "void arm_scale_q15 (\fBq15_t\fP * pSrc, \fBq15_t\fP scaleFract, int8_t shift, \fBq15_t\fP * pDst, uint32_t blockSize)"

.PP
Multiplies a Q15 vector by a scalar\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrc\fP points to the input vector 
.br
\fIscaleFract\fP fractional portion of the scale value 
.br
\fIshift\fP number of bits to shift the result by 
.br
\fIpDst\fP points to the output vector 
.br
\fIblockSize\fP number of samples in the vector 
.RE
.PP

.SS "void arm_scale_q31 (\fBq31_t\fP * pSrc, \fBq31_t\fP scaleFract, int8_t shift, \fBq31_t\fP * pDst, uint32_t blockSize)"

.PP
Multiplies a Q31 vector by a scalar\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrc\fP points to the input vector 
.br
\fIscaleFract\fP fractional portion of the scale value 
.br
\fIshift\fP number of bits to shift the result by 
.br
\fIpDst\fP points to the output vector 
.br
\fIblockSize\fP number of samples in the vector 
.RE
.PP

.SS "void arm_scale_q7 (\fBq7_t\fP * pSrc, \fBq7_t\fP scaleFract, int8_t shift, \fBq7_t\fP * pDst, uint32_t blockSize)"

.PP
Multiplies a Q7 vector by a scalar\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrc\fP points to the input vector 
.br
\fIscaleFract\fP fractional portion of the scale value 
.br
\fIshift\fP number of bits to shift the result by 
.br
\fIpDst\fP points to the output vector 
.br
\fIblockSize\fP number of samples in the vector 
.RE
.PP

.SS "void arm_shift_q15 (\fBq15_t\fP * pSrc, int8_t shiftBits, \fBq15_t\fP * pDst, uint32_t blockSize)"

.PP
Shifts the elements of a Q15 vector a specified number of bits\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrc\fP points to the input vector 
.br
\fIshiftBits\fP number of bits to shift\&. A positive value shifts left; a negative value shifts right\&. 
.br
\fIpDst\fP points to the output vector 
.br
\fIblockSize\fP number of samples in the vector 
.RE
.PP

.SS "void arm_shift_q31 (\fBq31_t\fP * pSrc, int8_t shiftBits, \fBq31_t\fP * pDst, uint32_t blockSize)"

.PP
Shifts the elements of a Q31 vector a specified number of bits\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrc\fP points to the input vector 
.br
\fIshiftBits\fP number of bits to shift\&. A positive value shifts left; a negative value shifts right\&. 
.br
\fIpDst\fP points to the output vector 
.br
\fIblockSize\fP number of samples in the vector 
.RE
.PP

.SS "void arm_shift_q7 (\fBq7_t\fP * pSrc, int8_t shiftBits, \fBq7_t\fP * pDst, uint32_t blockSize)"

.PP
Shifts the elements of a Q7 vector a specified number of bits\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrc\fP points to the input vector 
.br
\fIshiftBits\fP number of bits to shift\&. A positive value shifts left; a negative value shifts right\&. 
.br
\fIpDst\fP points to the output vector 
.br
\fIblockSize\fP number of samples in the vector 
.RE
.PP

.SS "void arm_sin_cos_f32 (\fBfloat32_t\fP theta, \fBfloat32_t\fP * pSinVal, \fBfloat32_t\fP * pCosVal)"

.PP
Floating-point sin_cos function\&. 
.PP
\fBParameters:\fP
.RS 4
\fItheta\fP input value in degrees 
.br
\fIpSinVal\fP points to the processed sine output\&. 
.br
\fIpCosVal\fP points to the processed cos output\&. 
.RE
.PP

.SS "void arm_sin_cos_q31 (\fBq31_t\fP theta, \fBq31_t\fP * pSinVal, \fBq31_t\fP * pCosVal)"

.PP
Q31 sin_cos function\&. 
.PP
\fBParameters:\fP
.RS 4
\fItheta\fP scaled input value in degrees 
.br
\fIpSinVal\fP points to the processed sine output\&. 
.br
\fIpCosVal\fP points to the processed cosine output\&. 
.RE
.PP

.SS "\fBfloat32_t\fP arm_sin_f32 (\fBfloat32_t\fP x)"

.PP
Fast approximation to the trigonometric sine function for floating-point data\&. end of LinearInterpolate group 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP input value in radians\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
sin(x)\&. 
.RE
.PP

.SS "\fBq15_t\fP arm_sin_q15 (\fBq15_t\fP x)"

.PP
Fast approximation to the trigonometric sine function for Q15 data\&. 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP Scaled input value in radians\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
sin(x)\&. 
.RE
.PP

.SS "\fBq31_t\fP arm_sin_q31 (\fBq31_t\fP x)"

.PP
Fast approximation to the trigonometric sine function for Q31 data\&. 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP Scaled input value in radians\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
sin(x)\&. 
.RE
.PP

.SS "void arm_std_f32 (\fBfloat32_t\fP * pSrc, uint32_t blockSize, \fBfloat32_t\fP * pResult)"

.PP
Standard deviation of the elements of a floating-point vector\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrc\fP is input pointer 
.br
\fIblockSize\fP is the number of samples to process 
.br
\fIpResult\fP is output value\&. 
.RE
.PP

.SS "void arm_std_q15 (\fBq15_t\fP * pSrc, uint32_t blockSize, \fBq15_t\fP * pResult)"

.PP
Standard deviation of the elements of a Q15 vector\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrc\fP is input pointer 
.br
\fIblockSize\fP is the number of samples to process 
.br
\fIpResult\fP is output value\&. 
.RE
.PP

.SS "void arm_std_q31 (\fBq31_t\fP * pSrc, uint32_t blockSize, \fBq31_t\fP * pResult)"

.PP
Standard deviation of the elements of a Q31 vector\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrc\fP is input pointer 
.br
\fIblockSize\fP is the number of samples to process 
.br
\fIpResult\fP is output value\&. 
.RE
.PP

.SS "void arm_sub_f32 (\fBfloat32_t\fP * pSrcA, \fBfloat32_t\fP * pSrcB, \fBfloat32_t\fP * pDst, uint32_t blockSize)"

.PP
Floating-point vector subtraction\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrcA\fP points to the first input vector 
.br
\fIpSrcB\fP points to the second input vector 
.br
\fIpDst\fP points to the output vector 
.br
\fIblockSize\fP number of samples in each vector 
.RE
.PP

.SS "void arm_sub_q15 (\fBq15_t\fP * pSrcA, \fBq15_t\fP * pSrcB, \fBq15_t\fP * pDst, uint32_t blockSize)"

.PP
Q15 vector subtraction\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrcA\fP points to the first input vector 
.br
\fIpSrcB\fP points to the second input vector 
.br
\fIpDst\fP points to the output vector 
.br
\fIblockSize\fP number of samples in each vector 
.RE
.PP

.SS "void arm_sub_q31 (\fBq31_t\fP * pSrcA, \fBq31_t\fP * pSrcB, \fBq31_t\fP * pDst, uint32_t blockSize)"

.PP
Q31 vector subtraction\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrcA\fP points to the first input vector 
.br
\fIpSrcB\fP points to the second input vector 
.br
\fIpDst\fP points to the output vector 
.br
\fIblockSize\fP number of samples in each vector 
.RE
.PP

.SS "void arm_sub_q7 (\fBq7_t\fP * pSrcA, \fBq7_t\fP * pSrcB, \fBq7_t\fP * pDst, uint32_t blockSize)"

.PP
Q7 vector subtraction\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrcA\fP points to the first input vector 
.br
\fIpSrcB\fP points to the second input vector 
.br
\fIpDst\fP points to the output vector 
.br
\fIblockSize\fP number of samples in each vector 
.RE
.PP

.SS "void arm_var_f32 (\fBfloat32_t\fP * pSrc, uint32_t blockSize, \fBfloat32_t\fP * pResult)"

.PP
Variance of the elements of a floating-point vector\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrc\fP is input pointer 
.br
\fIblockSize\fP is the number of samples to process 
.br
\fIpResult\fP is output value\&. 
.RE
.PP

.SS "void arm_var_q15 (\fBq15_t\fP * pSrc, uint32_t blockSize, \fBq15_t\fP * pResult)"

.PP
Variance of the elements of a Q15 vector\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrc\fP is input pointer 
.br
\fIblockSize\fP is the number of samples to process 
.br
\fIpResult\fP is output value\&. 
.RE
.PP

.SS "void arm_var_q31 (\fBq31_t\fP * pSrc, uint32_t blockSize, \fBq31_t\fP * pResult)"

.PP
Variance of the elements of a Q31 vector\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpSrc\fP is input pointer 
.br
\fIblockSize\fP is the number of samples to process 
.br
\fIpResult\fP is output value\&. 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for STM32_CMSIS from the source code\&.
